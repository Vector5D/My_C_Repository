# 单链表习题

首先给出单链表的一些基本函数，以此为基础实现单链表上的更多操作。

## 1.单链表的基本函数

```c
#include<stdio.h>
#include<stdlib.h>
#include<assert.h>
#include<string.h>

typedef int ElemType;
typedef struct ListNode {
	struct ListNode* next;
	ElemType data;
}ListNode;
typedef struct {
	struct ListNode* head;
	int cursize;
}LinkList;

template <class type>
void Swap(type& a, type& b) {
	int tmp = a;
	a = b;
	b = tmp;
}

ListNode* Buynode() {
	ListNode* s = (ListNode*)malloc(sizeof(ListNode));
	if (nullptr == s) exit(1);
	memset(s, 0, sizeof(ListNode));
	return s;
}

void Freenode(ListNode* s) {
	free(s);
}

void Init_List(LinkList* plist) {
	assert(plist != nullptr);
	plist->head = Buynode();
	plist->cursize = 0;
}

int Get_Size(LinkList* plist) {
	assert(plist != nullptr);
	return plist->cursize;
}

bool Is_Empty(LinkList* plist) {
	return Get_Size(plist) == 0;
}

void Print_List(LinkList* plist) {
	assert(plist != nullptr);
	ListNode* p = plist->head->next;
	while (p != nullptr) {
		printf("%5d", p->data);
		p = p->next;
	}
	printf("\n");
}

ListNode* FindVal(LinkList* plist, ElemType val) {
	assert(plist != nullptr);
	ListNode* p = plist->head->next;
	while (p != nullptr && p->data != val) {
		p = p->next;
	}
	return p;
}

/*
ListNode* FindVal_pre(LinkList* plist, ElemType val) {
	assert(plist != nullptr);
	ListNode* pre = plist->head;
	ListNode* q = pre->next;
	while (q != nullptr && q->data != val) {
		pre = q;
		q = q->next;
	}
	if (q == nullptr) {
		pre = nullptr;
	}
	return pre;
	}
*/

ListNode* FindVal_pre(LinkList* plist, ElemType val) {
	assert(plist != nullptr);
	ListNode* pre = plist->head;
	while (pre->next != nullptr && pre->next->data != val) {
		pre = pre->next;
	}
	if (pre->next == nullptr) {
		pre = nullptr;
	}
	return pre;
}

ListNode* FindPos(LinkList* plist, int pos) {
	assert(plist != nullptr);
	if (pos < 1 || pos > plist->cursize)return nullptr;
	ListNode* p = plist->head->next;
	int i = 1;
	while (i < pos) {
		p = p->next;
		i++;
	}
	return p;
}

ListNode* FindPos_pre(LinkList* plist, int pos) {
	assert(plist != nullptr);
	if (pos < 1 || pos > plist->cursize + 1)return nullptr;
	ListNode* p = plist->head;
	int i = 1;
	while (i < pos) {
		p = p->next;
		i++;
	}
	return p;
}

void Insert_Next(LinkList* plist, ListNode* pre, ElemType val) {
	assert(plist != nullptr);
	if (pre != nullptr) {
		ListNode* s = Buynode();
		s->data = val;
		s->next = pre->next;
		pre->next = s;
		plist->cursize += 1;
	}
}

bool Insert_Item(LinkList* plist, int pos, ElemType val) {
	ListNode* pre = FindPos_pre(plist, pos);
	if (pre == nullptr) return false;
	Insert_Next(plist, pre, val);
	return true;
}

void push_back(LinkList* plist, ElemType val) {
	Insert_Item(plist, plist->cursize + 1, val);
}

void push_front(LinkList* plist, ElemType val) {
	Insert_Item(plist, 1, val);
}

void Insert_Ar(LinkList* plist, int pos, ElemType* ar, int n) {
	for (int i = 0;i < n;i++) {
		Insert_Item(plist, pos, ar[i]);
	}
}

void Insert_value(LinkList* plist, int pos, ElemType val, int n) {
	for (int i = 0;i < n;i++) {
		Insert_Item(plist, pos, val);
	}
}

void Erase_Next(LinkList* plist, ListNode* pre) {
	assert(plist != nullptr);
	if (pre != nullptr && pre->next != nullptr) {
		ListNode* q = pre->next;
		pre->next = q->next;
		Freenode(q);
		q = nullptr;
		plist->cursize -= 1;
	}
}

bool Erase_Pos(LinkList* plist, int pos) {
	ListNode* pre = FindPos_pre(plist, pos);
	if (pre == nullptr || pre->next == nullptr) return false;
	Erase_Next(plist, pre);
	return true;
}

void pop_back(LinkList* plist) {
	Erase_Pos(plist, plist->cursize);
}

void pop_front(LinkList* plist) {
	Erase_Pos(plist, 1);
}

bool remove(LinkList* plist, ElemType val) {
	ListNode* pre = FindVal_pre(plist, val);
	if (pre == nullptr)return false;
	Erase_Next(plist, pre);
	return true;
}

void remove_all(LinkList* plist, ElemType val) {
	ListNode* q = plist->head;
	while (q->next != nullptr) {
		if (q->next->data == val) {
			Erase_Next(plist, q);
		}
		else {
			q = q->next;
		}
	}
}

/*
void Clear_List(LinkList* plist) {
	assert(plist != nullptr);
	ListNode* q = plist->head;
	while (q->next != nullptr) {
		remove_all(plist, q->next->data);
	}
}
*/

void Clear_List(LinkList* plist) {
	assert(plist != nullptr);
	ListNode* q = plist->head;
	while (q->next != nullptr) {
		Erase_Next(plist, q);
	}
}

void Destroy_List(LinkList* plist) {
	assert(plist != nullptr);
	Clear_List(plist);
	Freenode(plist->head);
	plist->head = nullptr;
}
```

## 2.单链表的逆置

### 2.1使用头结点

```c
void Reverse1(LinkList* plist) {
	assert(plist != nullptr);
	if (plist->cursize < 2)return;
	ListNode* p = plist->head->next;
	ListNode* s = nullptr;
	plist->head->next = nullptr;
	while (p != nullptr) {
		s = p;
		p = p->next;
		s->next = plist->head->next;
		plist->head->next = s;
	}
}
```

当结点个数大于等于两个时进行逆置操作。首先将链表从头结点处断开，使用两个指针，p指针要指向原链表剩余的部分，防止链表断开后结点的丢失；s指针使用原有结点在头结点处进行“头插”的操作。当然，我们还可以直接调用头插函数来完成这个工作，如下面代码所示：

```c
void Reverse2(LinkList* plist) {
	assert(plist != nullptr);
	if (plist->cursize < 2)return;
	ListNode* p = plist->head->next;
	ListNode* q = nullptr;
	plist->head->next = nullptr;
	while (p != nullptr) {
		q = p->next;
		push_front(plist, p->data);
		Freenode(p);
		p = q;
	}
}
```

以上两种形式本质上没有区别。前者其实是将原先链表中的结点重新拼接成为了新的逆置链表，而后者只使用原先链表中的数值，调用头插函数插入数值并释放了旧的结点，并申请了新的结点用以形成逆置链表。

### 2.2不使用头结点

```c
ListNode* Reverse3(ListNode* firstnode) {
	if (firstnode == nullptr || firstnode->next == nullptr)return firstnode;
	ListNode* p = firstnode;
	firstnode = nullptr;
	while (p != nullptr) {
		ListNode* s = p;
		p = p->next;
		s->next = firstnode;
		firstnode = s;
	}
	return firstnode;
}
```

对于没有头结点的情况较为复杂，一种方法是人为的创建一个头结点，然后按照有头结点的方式去逆置链表。不过我们不采用这种方式，选择不创建任何头结点，直接对链表进行操作。注意观察指针p和s的移动，而且由于没有头结点，所以指针firstnode的位置是不断改变的。

### 2.3采用递归的方法

```c
ListNode* RevList(ListNode* pre, ListNode* p) {
	ListNode* tail = nullptr;
	if (p != nullptr) {
		tail = RevList(p, p->next);
		p->next = pre;
	}
	else {
		tail = pre;
	}
	return tail;
}
void ListReverse(LinkList* plist) {
	assert(plist != nullptr);
	plist->head->next = RevList(nullptr, plist->head->next);
}
```

向递归函数传入一个空指针和第一个结点的地址，进入递归函数中层层递推。当指针p为空的时候指针pre为尾结点，此时将尾结点地址赋值给指针tail，此时tail指针保存着尾结点的地址进行回归，这是返回值的情况。另一方面，我们每次递推都保存有pre指针和p指针，分别代表链表的一对前驱结点和当前结点，那么从递推的最深一层开始（找到了尾结点的位置），我们逆向连接两个结点（p->next = pre），这样每回归到上一层我们都可以逆接一对结点直到回归完成，整个递归结束，完成了链表的逆置。

## 3.删除结点（时间复杂度为O(1)）

一般情况下，对于单链表删除结点一般是找到该结点的前驱结点，然后才能进行删除操作。但是找到某个结点的前驱需要遍历整个链表，时间复杂度为O(n)。有什么办法可以直接删除给定的结点，并且将时间复杂度降低到O(1)呢？

```c
bool DelectPoint(LinkList* plist, ListNode* pnode) {
	assert(plist != nullptr && pnode != nullptr);
	if (pnode->next == nullptr) {
		return Erase_Pos(plist, plist->cursize);
	}
	ListNode* p = pnode->next;
	pnode->data = p->data;
	pnode->next = p->next;
	Freenode(p);
	p = nullptr;
	return true;
}
```

将待删除结点的后项结点找到，单链表的结点虽然不能直接找到前驱，但是寻找后继的时间复杂度为O(1)。通过将后继结点的数据域和指针域拷贝给待删除结点，然后释放后继结点的方式，我们相当于间接地“删除”了当前结点，并将时间复杂度降为了O(1)。 需要注意的是，这种方式不能用来删除尾结点，因为尾结点不存在后继。

## 4.判断链表是否相交

链表相交的条件就是两个链表从某个结点开始地址重合，那么就称为链表相交。那么我们如何判断两个链表相交，并将第一个相交的结点返回？

```c
ListNode* Intersect(LinkList* plist1, LinkList* plist2) {
	assert(plist1 != nullptr && plist2 != nullptr);
	int len1 = plist1->cursize;
	int len2 = plist2->cursize;
	ListNode* p = len1 > len2 ? plist1->head : plist2->head;
	ListNode* q = len1 > len2 ? plist2->head : plist1->head;
	for (int i = 0;i < abs(len1 - len2);i++) {
		p = p->next;
	}
	while (p != nullptr) {
		if (p == q) {
			return p;
		}
		p = p->next;
		q = q->next;
	}
	return nullptr;
}
```

如果两个链表首先出现一对结点相同时，后面的所有结点一定也是相同的，这是由于链表只有唯一固定的指针域决定的。我们首先要比较两个链表的长度，移动指向较长链表的指针，使其指针所指向的结点到尾结点的长度等于较短链表的长度。然后两两比较结点的地址，如果发现结点的地址相同，将其返回，如果知道链表的末尾仍没有发现相同的结点，返回空指针退出。

## 5.返回链表倒数第k个结点

```c
ListNode* GetendK(LinkList* plist, int k) {
	assert(plist != nullptr && k > 0 && k <= plist->cursize);
	ListNode* p = plist->head;
	ListNode* q = plist->head;
	for (int i = 0;i < k;i++) {
		p = p->next;
	}
	while (p != nullptr) {
		p = p->next;
		q = q->next;
	}
	return q;
}
```

采用两个指针，都指向头结点。首先指针p移动k次，指针q仍然指向头结点，然后使这两个指针遍历链表。由于指针p在指针q之前k个位置，所以它一定会比指针q先到达链表的尾部，而且这时候返回指针q所保存的结点地址，正好就是链表倒数第k个结点的地址。

## 6.判断单链表是否存在环

如果一个单链表从某一个结点开始，向后面遍历若干个结点之后能回到该结点，那么这个单链表存在环。判断一个单链表是否存在环，如果存在，返回其一开始形成环的结点、

```c
ListNode* IsLoop(LinkList* plist) {
	assert(plist != nullptr);
    //判断是否存在环
	ListNode* fast = plist->head;
	ListNode* slow = plist->head;
	while (1) {
		if (fast == nullptr || fast->next == nullptr) {
			return nullptr;
		}
		fast = fast->next->next;
		slow = slow->next;
		if (fast == slow) {
			break;
		}
	}
    //寻找第一个形成环的结点
	ListNode* p = plist->head;
	ListNode* q = fast;//slow;
	while (p != q) {
		p = p->next;
		q = q->next;
	}
	return p;//return q;
}
```

程序分为两个部分：首先是判断是否存在环。如果一个链表不存在环，那么一定存在尾结点，所以我们如果找到了尾结点可以直接退出函数返回一个空指针；对于有环的情况，我们定义两个指针，一个指针一次移动一次，一个指针指针移动两次，由于两个指针的“速度”不同，那么在环当中一定会存在两个指针“相遇”的情况，即两个指针的值相等。根据这个逻辑，我们得到了前半部分的代码。

如果单链表真的存在环，要找到入环结点。根据数学知识推理得出，“相遇”结点到入环结点的长度和链表头结点到入环结点的长度相等。根据这个逻辑得到后半部分的代码。

## 7.单链表选择排序

```c
void SelectSort(LinkList* plist) {
	assert(plist != nullptr);
	if (plist->head->next == nullptr)return;
	ListNode* p = plist->head->next;
	
	while (p->next != nullptr) {
		ListNode* pmin = p;
		ListNode* s = p->next;
		while (s != nullptr) {
			if (pmin->data > s->data) {
				pmin = s;
			}
			s = s->next;
		}
		Swap(p->data, pmin->data);
		p = p->next;
	}
}
```

注意指针的移动方式。首先指针pmin指向第一个数据结点，指针s遍历链表，和指针pmin的数据域比较，找到最小数据结点，然后令pmin指向它，交换pmin和第一个数据结点，这样就可以把链表中最小的数据结点交换到第一个位置，以此类推，直到所有结点有序。还需要注意循环退出条件。由于选择排序的特性，每次循环都会唯一确定一个结点的位置，当剩下最后一个结点没有进入循环时，此时整个链表已经有序，所以我们将循环退出条件设定为p->next != nullptr。

## 8.单链表快速排序

```c
ListNode* partition(ListNode* left,ListNode* right) {
	ListNode* p = left->next;
	ListNode* tail = left;
	int pivot = tail->data;
	while (p != right) {
		if (p->data <= pivot) {
			tail = tail->next;
			Swap(p->data, tail->data);
		}
		p = p->next;
	}
	Swap(left->data, tail->data);
	return tail;
}
void ListPass(ListNode* left, ListNode* right) {
	if (left != right) {
		ListNode* pivot = partition(left, right);
		ListPass(left, pivot);
		ListPass(pivot->next, right);
	}
}
void ListQuickSort(LinkList* plist) {
	assert(plist != nullptr);
	ListPass(plist->head->next, nullptr);
}
```

首先来看划分部分，对于一组数据，我们首先将左边结点的数据域设置为枢轴（pivot = tail->data），控制两个指针tail和p通过交换结点数据域内容的方式，使小于等于枢轴的都在左边，大于枢轴的都在右边，这样就排定了一个数的位置。通过递归的方式，不断使用划分函数，最终完成整个链表的快速排序。

## 9.单链表插入排序

```c
void InsertSort(LinkList* plist) {
	assert(plist != nullptr);
	if (plist->head->next == nullptr)return;
	ListNode* p, * pre, * q;
	p = plist->head->next->next;
	plist->head->next->next = nullptr;

	while (p != nullptr) {
		q = p->next;
		pre = plist->head;
		while (pre->next != nullptr && pre->next->data < p->data) {
			pre = pre->next;
		}
		p->next = pre->next;
		pre->next = p;
		p = q;
	}
}
```

保留单链表中一个结点，该结点视为有序结点。通过pre指针指向有序结点，通过p指针指向剩余结点，比较这两个指针数据域的大小，将每一个无序结点插入到有序结点当中，q指针保证每一次正确插入后p指针可以重新指向下一个无序结点。

## 对比：数组的三种常用排序

```c
void SelectSort(int* ar, int n) {//数组选择排序
	assert(ar != nullptr);
	for (int i = 0;i < n - 1; i++) {
		int min = i;
		for (int j = i + 1;j < n;j++) {
			if (ar[min] > ar[j]) {
				min = j;
			}
		}
		if (min != i) {
			int tmp = ar[i];
			ar[i] = ar[min];
			ar[min] = tmp;
		}
	}
}

int Partition(int* ar, int left,int right) {//数组快速排序
	assert(ar != nullptr);
	int j = left - 1;
	int i = left;
	int pivot = ar[i];
	while (i < right) {
		if (ar[i] <= pivot) {
			j = j + 1;
			Swap(&ar[j], &ar[i]);
		}
		i++;
	}
	Swap(&ar[j], &ar[left]);
	return j;
}

void InsertSort(int* ar, int n) {//数组插入排序
	assert(ar != nullptr);
	for (int i = 1;i < n;i++) {
		for (int j = i;j > 0 && (ar[j] < ar[j - 1]);j--) {
			int tmp = ar[j];
			ar[j] = ar[j - 1];
			ar[j - 1] = tmp;
		}
	}
}
```

