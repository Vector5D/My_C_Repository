# 1.线性表

## 1.1顺序表

顺序表是线性表的一种，以数组作为基本实现方式。其中数组长度固定成为定长线性表，长度可变则成为变长顺序表。相较于定长顺序表，变长顺序表的用途更为广泛，所以下面给出变长顺序表的相关操作以供参考。

```c
#include<stdio.h>
#include<stdlib.h>
#include<assert.h>
#define INIT_SIZE 10//规定数组的初始长度

typedef struct SQlist {
	int* data;//动态申请内存
	int length;//线性表中当前有效元素个数
	int maxsize;//线性表中最大有效元素个数
}SQlist, * PSQlist;

void Init_List(PSQlist plist){
    //初始化顺序表
	assert(plist != nullptr);
	plist->data = (int*)malloc(sizeof(int) * INIT_SIZE);//动态内存分配
	if (plist->data == nullptr)exit(1);
	plist->length = 0;//设定初始有效元素个数为零
	plist->maxsize = INIT_SIZE;//设定最大有效元素长度
}

bool Isempty(PSQlist plist) {
    //判断顺序表是否为空，其实就是判断其有效元素个数是否为零
	assert(plist != nullptr);
	return plist->length == 0;
}

bool Isfull(PSQlist plist) {
    //如果当前顺序表中有效元素的个数与最大有效元素个数相同则满
	assert(plist != nullptr);
	return plist->length == plist->maxsize;
}

void Inc(PSQlist plist) {
	//每当顺序表满的时候，应该使用扩容函数扩容
	int* pnew;
	pnew = (int*)realloc(plist->data, sizeof(int) * plist->maxsize * 2);
    //规定扩充的内存相当于之前空间的2倍
	if (pnew == nullptr)exit(1);
	plist->data = pnew;
	plist->maxsize *= 2;//修改顺序表当前最大有效元素个数
}

int Search(PSQlist plist, int val) {
    //查找指定数值的元素并返回其下标
	assert(plist != nullptr);
	for (int i = 0;i < plist->length;i++) {
		if (val == plist->data[i]) {
			return i;
		}
	}
	return -1;//如果没有这个数值则返回-1表示查找失败
}

bool Insert(PSQlist plist, int pos, int val) {
    //在指定位置插入指定数值的元素
	assert(plist != nullptr);
	if (pos < 0 || pos > plist->length) {
        //判断插入位置的合法性
		return false;
	}
	if (Isfull(plist)) {
        //如果顺序表满，则进行扩容
		Inc(plist);
	}
	for (int i = plist->length - 1;i >= pos;i--) {
        //到插入位置为止，从后向前依次挪动元素
		plist->data[i + 1] = plist->data[i];
	}
	plist->data[pos] = val;
	plist->length += 1;
	return true;
}

bool Del_Pos(PSQlist plist, int pos) {
    //删除指定位置的元素
	assert(plist != nullptr);
	if (pos < 0 || pos >= plist->length) {
		return false;
	}
	for (int i = pos;i < plist->length - 1;i++) {
        //从删除位置开始，从前向后挪动元素
		plist->data[i] = plist->data[i + 1];
	}
	plist->length -= 1;
	return true;
}

bool Del_Val(PSQlist plist, int val) {
    //删除指定数值的元素
	assert(plist != nullptr);
	int i = Search(plist, val);//通过数值找到元素下标
	if (i == -1) {
		return false;
	}
	Del_Pos(plist, i);//通过元素下标删除对应元素
	return true;
}

void Print_List(PSQlist plist) {
    //打印函数
	assert(plist != nullptr);
	for (int i = 0; i < plist->length;i++) {
		printf("%d ", plist->data[i]);
	}
	printf("\n");
}

void Clear_List(PSQlist plist) {
    //清空函数，将有效元素个数置为零则视为清空
	assert(plist != nullptr);
	plist->length = 0;
}

void Destroy_List(PSQlist plist) {
    //销毁函数，释放堆区申请的内存，并将对应指针置为空
	assert(plist != nullptr);
	free(plist->data);
	plist->data = nullptr;
	plist->length = 0;
	plist->maxsize = 0;
}

int Get_Length(PSQlist plist) {
    //获取顺序表当前有效元素的个数
	assert(plist != nullptr);
	return plist->length;
}
```

## 1.2链表

链表是实现线性表的第二种形式，其中又可以分为单链表、循环单链表、双链表、循环双链表等。这里给出循环单链表以及循环双链表的代码实现以供参考。

### 1.2.1循环单链表

```c
#include<stdio.h>
#include<stdlib.h>
#include<assert.h>

typedef int ELEM_TYPE;
typedef struct CNode {
	//单向循环链表
	struct CNode* next;
	ELEM_TYPE data;
}CNode, * PCList;

void Init_List(PCList pclist){
	//初始化循环链表
	assert(pclist != nullptr);
	if (pclist == nullptr)
		exit(EXIT_FAILURE);
	pclist->next = pclist;
}

bool Insert_Head(PCList pclist, ELEM_TYPE val) {
	//头插法
	assert(pclist != nullptr);
	if (pclist == nullptr)
		exit(EXIT_FAILURE);

	CNode* p = (CNode*)malloc(sizeof(CNode));
	if (p == nullptr) {
		printf("malloc failed\n");
		exit(EXIT_FAILURE);
	}

	p->data = val;
	p->next = pclist->next;
	pclist->next = p;

	return true;
}

int Get_Length(PCList pclist) {
	//获得循环链表的长度
	assert(pclist != nullptr);
	if (pclist == nullptr)
		exit(EXIT_FAILURE);

	CNode* p = pclist;
	int count = 0;
	while (p->next != pclist) {
		count += 1;
		p = p->next;
	}

	return count;
}

bool Insert_Tail(PCList pclist, ELEM_TYPE val) {
	//尾插法
	assert(pclist != nullptr);
	if (pclist == nullptr)
		exit(EXIT_FAILURE);

	CNode* p = pclist;
	while (p->next != pclist) {
		p = p->next;
	}

	CNode* q = (CNode*)malloc(sizeof(CNode));
	if (q == nullptr) {
		printf("malloc failed\n");
		exit(EXIT_FAILURE);
	}

	q->data = val;
	q->next = p->next;
	p->next = q;

	return true;
}

bool Del_Head(PCList pclist) {
	//从头部删除
	assert(pclist != nullptr);
	if (pclist == nullptr)
		exit(EXIT_FAILURE);

	if (Get_Length(pclist) == 0) {
		printf("empty list\n");
		return false;
	}

	CNode* p = pclist->next;
	pclist->next = p->next;
	free(p);
	p = nullptr;

	return true;
}

bool Del_Tail(PCList pclist) {
	//从尾部删除
	assert(pclist != nullptr);
	if (pclist == nullptr)
		exit(EXIT_FAILURE);

	if (Get_Length(pclist) == 0) {
		printf("empty list\n");
		return false;
	}

	CNode* p = pclist;
	int size = Get_Length(pclist);
	int i = 1;
	while (i < size) {
		p = p->next;
		i += 1;
	}

	CNode* q = p->next;
	p->next = q->next;
	free(q);
	q = nullptr;

	return true;
}

CNode* Search_Val(PCList pclist, ELEM_TYPE val) {
	//查找并返回值为val的结点
	assert(pclist != nullptr);
	if (pclist == nullptr)
		exit(EXIT_FAILURE);

	CNode* p = pclist->next;
	while (p != pclist) {
		if (p->data == val) {
			return p;
		}
		p = p->next;
	}
	return nullptr;
}

CNode* Search_Val_Prior(PCList pclist, ELEM_TYPE val) {
	//查找并返回值为val结点的前驱结点
	assert(pclist != nullptr);
	if (pclist == nullptr)
		exit(EXIT_FAILURE);

	CNode* p = pclist;
	while (p->next != pclist) {
		if (p->next->data == val) {
			return p;
		}
		p = p->next;
	}
	return nullptr;
}

CNode* Search_Val_Next(PCList pclist, ELEM_TYPE val) {
	//查找并返回值为val结点的后继结点
	CNode* p = Search_Val(pclist, val);
	if (p == nullptr)return nullptr;
	return p->next;
}

bool Insert_Val(PCList pclist, int pos, ELEM_TYPE val) {
	//指定位置插入值为val的结点
	assert(pclist != nullptr);
	if (pclist == nullptr)
		exit(EXIT_FAILURE);

	if (pos < 0 || pos > Get_Length(pclist)) {
		printf("pos error\n");
		return false;
	}

	CNode* p = pclist;
	for (int i = 0;i < pos;i++) {
		p = p->next;
	}

	CNode* q = (CNode*)malloc(sizeof(CNode));
	if (q == nullptr) {
		printf("malloc error\n");
		exit(EXIT_FAILURE);
	}

	q->data = val;
	q->next = p->next;
	p->next = q;

	return true;
}

bool Del_Pos(PCList pclist, int pos) {
	//删除指定位置的结点
	assert(pclist != nullptr);
	if (pclist == nullptr)
		exit(EXIT_FAILURE);

	if (pos < 0 || pos >= Get_Length(pclist)) {
		printf("pos error\n");
		return false;
	}

	CNode* p = pclist;
	for (int i = 0;i < pos;i++) {
		p = p->next;
	}

	CNode* q = p->next;
	p->next = q->next;
	free(q);
	q = nullptr;

	return true;
}

bool Del_Val(PCList pclist, ELEM_TYPE val) {
	//删除第一个指定数据的结点
	assert(pclist != nullptr);
	if (pclist == nullptr)
		exit(EXIT_FAILURE);

	CNode* p = Search_Val_Prior(pclist, val);
	if (p == nullptr) {
		printf("can't find val\n");
		return false;
	}

	CNode* q = p->next;
	p->next = q->next;
	free(q);
	q = nullptr;

	return true;
}

void Print_List(PCList pclist) {
	//打印链表
	assert(pclist != nullptr);
	if (pclist == nullptr)
		exit(EXIT_FAILURE);

	if (Get_Length(pclist) == 0) {
		printf("this is an empty clist\n");
		return;
	}

	CNode* p = pclist->next;
	while (p != pclist) {
		printf("%5d", p->data);
		p = p->next;
	}
	printf("\nlength = %d\n", Get_Length(pclist));
}

void Clear_List(PCList pclist) {
	//清空链表
	assert(pclist != nullptr);
	if (pclist == nullptr)
		exit(EXIT_FAILURE);

	while (pclist->next != pclist) {
		Del_Head(pclist);
	}
}

void Destroy_List(PCList& pclist) {
	//销毁链表
	assert(pclist != nullptr);
	if (pclist == nullptr)
		exit(EXIT_FAILURE);

	Clear_List(pclist);
	free(pclist);
	pclist = nullptr;
	printf("clist is already destroyed\n");
}
```

### 1.2.2循环双链表（一）

```c
#include<stdio.h>
#include<stdlib.h>
#include<assert.h>

typedef int ELEM_TYPE
typedef struct DCNode {
    //循环双向链表
	ELEM_TYPE data;
	struct DCNode* next;
	struct DCNode* prior;
}DCNode, * PDCList;

void Init_Dlist(PDCList pdclist) {
    //初始化双向循环链表
	assert(pdclist != nullptr);
	if (pdclist == nullptr)exit(EXIT_FAILURE);
	//在没有结点的情况下，将头结点的前驱和后继指向自己
	pdclist->next = pdclist;
	pdclist->prior = pdclist;
}

bool Insert_Head(PDCList pdclist, ELEM_TYPE val) {
    //头插法
	assert(pdclist != nullptr);
	if (pdclist == nullptr)exit(EXIT_FAILURE);

	DCNode* p = (DCNode*)malloc(sizeof(DCNode));
	if (p == nullptr) {
		printf("malloc failed\n");
		exit(EXIT_FAILURE);
	}
	//注意插入时指针域之间的关系
	p->data = val;
	p->next = pdclist->next;
	p->prior = pdclist;
	pdclist->next->prior = p;
	pdclist->next = p;
	
	return true;
}

bool Insert_Tail(PDCList pdclist, ELEM_TYPE val) {
    //尾插法
	assert(pdclist != nullptr);
	if (pdclist == nullptr)exit(EXIT_FAILURE);

	DCNode* p = (DCNode*)malloc(sizeof(DCNode));
	if (p == nullptr) {
		printf("malloc failed\n");
		exit(EXIT_FAILURE);
	}
	//由于循环双向链表，我们在头结点之前插入元素等价于向尾部插入结点
	p->data = val;
	p->next = pdclist;
	p->prior = pdclist->prior;
	pdclist->prior->next = p;
	pdclist->prior = p;

	return true;
}

int Get_Length(PDCList pdclist) {
    //得到双向链表的长度
	assert(pdclist != nullptr);
	if (pdclist == nullptr)exit(EXIT_FAILURE);

	DCNode* p = pdclist;
	int count = 0;
	while (p->next != pdclist) {
        //注意循环结束条件
		p = p->next;
		count += 1;
	}
	return count;
}

bool Insert_Val(PDCList pdclist, int pos, ELEM_TYPE val) {
    //在指定位置插入指定数值的结点
	assert(pdclist != nullptr);
	if (pdclist == nullptr)exit(EXIT_FAILURE);

	if (pos < 0 || pos > Get_Length(pdclist)) {
		printf("pos error\n");
		return false;
	}
	//定位指定位置的前驱结点
	DCNode* p = pdclist;
	for (int i = 0;i < pos;i++) {
		p = p->next;
	}

	DCNode* q = (DCNode*)malloc(sizeof(DCNode));
	if (q == nullptr) {
		printf("malloc failed\n");
		exit(EXIT_FAILURE);
	}

	q->data = val;
	q->prior = p;
	q->next = p->next;
	p->next->prior = q;
	p->next = q;

	return true;
}

bool Del_Head(PDCList pdclist) {
    //从头部删除
	assert(pdclist != nullptr);
	if (pdclist == nullptr)exit(EXIT_FAILURE);

	if (Get_Length(pdclist) == 0) {
		printf("empty list\n");
		return false;
	}

	DCNode* p = pdclist->next;
	p->prior->next = p->next;
	p->next->prior = p->prior;
	free(p);
	p = nullptr;

	return true;
}

bool Del_Tail(PDCList pdclist) {
    //从尾部删除
	assert(pdclist != nullptr);
	if (pdclist == nullptr)exit(EXIT_FAILURE);

	if (Get_Length(pdclist) == 0) {
		printf("empty list\n");
		return false;
	}

	DCNode* p = pdclist->prior;
	p->prior->next = p->next;
	p->next->prior = p->prior;
	free(p);
	p = nullptr;

	return true;
}

bool Del_Pos(PDCList pdclist, int pos) {
    //删除指定位置的结点元素
	assert(pdclist != nullptr);
	if (pdclist == nullptr)exit(EXIT_FAILURE);

	if (pos < 0 || pos >= Get_Length(pdclist)) {
		printf("pos error\n");
		return false;
	}
	//定位指定位置的前驱结点
	DCNode* p = pdclist;
	for (int i = 0;i < pos;i++) {
		p = p->next;
	}
	//删除指定结点
	DCNode* q = p->next;
	q->prior->next = q->next;
	q->next->prior = q->prior;
	free(q);
	q = nullptr;

	return true;
}

DCNode* Search_Val(PDCList pdclist, ELEM_TYPE val) {
    //查询等于指定数值的结点并将其返回
	assert(pdclist != nullptr);
	if (pdclist == nullptr)exit(EXIT_FAILURE);

	DCNode* p = pdclist->next;
	while (p != pdclist) {
		if (p->data == val) {
			return p;
		}
		p = p->next;
	}
	return nullptr;
}

DCNode* Search_Val_Prior(PDCList pdclist, ELEM_TYPE val) {
    //查询等于指定数值的结点并返回其前驱
	DCNode* p = Search_Val(pdclist,val);
	if (p == nullptr)return nullptr;
	return p->prior;
}

DCNode* Search_Val_Next(PDCList pdclist, ELEM_TYPE val) {
    //查询等于指定数值的结点并返回其后继
	DCNode* p = Search_Val(pdclist, val);
	if (p == nullptr)return nullptr;
	return p->next;
}

bool Del_Val(PDCList pdclist, ELEM_TYPE val) {
    //删除第一个等于指定数值的结点
	assert(pdclist != nullptr);
	if (pdclist == nullptr)exit(EXIT_FAILURE);
	//通过指定数值找到对应结点
	DCNode* p = Search_Val(pdclist, val);
	if (p == nullptr) {
		printf("can't find val\n");
		return false;
	}
	//删除该结点
	p->prior->next = p->next;
	p->next->prior = p->prior;
	free(p);
	p = nullptr;

	return true;
}

void Print_Dlist(PDCList pdclist) {
    //打印函数
	assert(pdclist != nullptr);
	if (pdclist == nullptr)exit(EXIT_FAILURE);

	if (Get_Length(pdclist) == 0) {
		printf("this is an empty list\n");
		return;
	}

	DCNode* p = pdclist->next;
	while (p != pdclist) {
		printf("%5d", p->data);
		p = p->next;
	}
	printf("\nlength = %d\n", Get_Length(pdclist));
}

void Clear_Dlist(PDCList pdclist) {
    //清空函数，循环调用从头删除函数直到链表为空
	assert(pdclist != nullptr);
	if (pdclist == nullptr)exit(EXIT_FAILURE);

	while (pdclist->next != pdclist) {
		Del_Head(pdclist);
	}
}

void Destroy_Dlist(PDCList& pdclist) {
    //销毁函数，清空链表之后释放头结点
	assert(pdclist != nullptr);
	if (pdclist == nullptr)
		exit(EXIT_FAILURE);

	Clear_Dlist(pdclist);
	free(pdclist);
	pdclist = nullptr;
	printf("dlist is already destroyed\n");
}
```

### 1.2.3循环双链表（二）

```c
#include<stdio.h> 
#include<stdlib.h>	 
#include<assert.h>
#include<string.h>

typedef int ElemType;
typedef struct ListNode {
	ElemType data;
	struct ListNode* priv;
	struct ListNode* next;
}ListNode;
typedef struct {
	struct ListNode* head;
	int cursize;
}DuLinkList;

static ListNode* Buynode(ListNode* pre, ListNode* p) {
    //购买结点
	ListNode* s = (ListNode*)malloc(sizeof(ListNode));
	if (s == nullptr)exit(1);
	memset(s, 0, sizeof(ListNode));
    //如果是头结点，就将其指针域全部指向自己
	s->next = (p == nullptr) ? s : p;
	s->priv = (pre == nullptr) ? s : pre;
	return s;
}
static void Freenode(ListNode* p) {
    //释放结点
	free(p);
}
void Init_List(DuLinkList* plist) {
    //初始化链表
	assert(plist != nullptr);
	plist->head = Buynode();
	plist->cursize = 0;
}
void Print_List(DuLinkList* plist) {
    //打印链表
	assert(plist != nullptr);
	if (plist->head == nullptr) {
		printf("\"the list is already destroyed\"");
		exit(1);
	}
	else if (plist->cursize == 0) {
		printf("\"this is an empty list\"\n");
		return;
	}
	ListNode* p = plist->head->next;
	while (p != plist->head) {
		printf("%5d", p->data);
		p = p->next;
	}
	printf("\n");
}
int GetSize(DuLinkList* plist) {
    //获取当前链表的长度
	assert(plist != nullptr);
	return plist->cursize;
}
bool Is_Empty(DuLinkList* plist) {
    //判空
	return GetSize(plist) == 0;
}
ListNode* FindValue(DuLinkList* plist, ElemType val) {
    //找到指定数值并返回对应结点
	assert(plist != nullptr);
	ListNode* p = plist->head->next;
	while (p != plist->head && p->data != val) {
		p = p->next;
	}
	if (p == plist->head)p = nullptr;
	return p;
}
ListNode* FindPos(DuLinkList* plist, int pos) {
    //找到指定位置并返回对应结点
	assert(plist != nullptr);
	if (pos < 1 || pos > plist->cursize + 1)return nullptr;
	ListNode* p = plist->head;
	while (pos != 0) {
		p = p->next;
		pos -= 1;
	}
	return p;
}
void Insert(DuLinkList* plist, ListNode* p, ElemType val) {
    //在指定结点的前面插入
	assert(plist != nullptr);
	if (p != nullptr) {
		ListNode* s = Buynode(p->priv, p);
		s->data = val;
		p->priv->next = s;
		p->priv = s;
		plist->cursize += 1;
	}
}
bool Insert_Item(DuLinkList* plist, int pos, ElemType val) {
    //给出指定位置和数值，并在该位置对应结点的前面插入
	assert(plist != nullptr);
	ListNode* p = FindPos(plist, pos);
	if (p == nullptr)return false;
	Insert(plist, p, val);
	return true;
}
void push_back(DuLinkList* plist, ElemType val) {
    //尾插法
	Insert(plist, plist->head, val);
}
void push_front(DuLinkList* plist, ElemType val) {
    //头插法
	Insert(plist, plist->head->next, val);
}
void Insert_Ar(DuLinkList* plist, int pos, ElemType* ar, int n) {
    //在指定位置插入数组
	for (int i = 0;i < n;i++) {
		Insert_Item(plist, pos, ar[i]);
	}
}
void Insert_Val(DuLinkList* plist, int pos, ElemType val, int n) {
    //在指定位置插入若干相同元素
	for (int i = 0;i < n;i++) {
		Insert_Item(plist, pos, val);
	}
}
void Erase(DuLinkList* plist, ListNode* p) {
    //删除指定结点
	assert(plist != nullptr);
	if (p != nullptr) {
		p->priv->next = p->next;
		p->next->priv = p->priv;
		Freenode(p);
		p = nullptr;
		plist->cursize -= 1;
	}
}
bool Erase_Pos(DuLinkList* plist, int pos) {
    //删除指定位置的结点
	assert(plist != nullptr);
	ListNode* p = FindPos(plist, pos);
	if (p == nullptr)return false;
	Erase(plist, p);
	return true;
}
void pop_back(DuLinkList* plist) {
    //从尾部删除
	Erase(plist, plist->head->priv);
}
void pop_front(DuLinkList* plist) {
    //从头部删除
	Erase(plist, plist->head->next);
}
void remove(DuLinkList* plist, ElemType val) {
    //删除第一个等于指定数值的结点
	assert(plist != nullptr);
	ListNode* p = FindValue(plist, val);
	if (p == nullptr)return;
	Erase(plist, p);
}
void remove_all(DuLinkList* plist, ElemType val) {
    //删除所有等于指定数值的结点
	assert(plist != nullptr);
	ListNode* p = plist->head;
	while (p->next != plist->head) {
		if (p->next->data == val) {
			Erase(plist, p->next);
		}
		else {
			p = p->next;
		}
	}
}
void Clear_List(DuLinkList* plist) {
    //清空链表
	assert(plist != nullptr);
	while(plist->cursize != 0) {
		Erase(plist, plist->head->next);
	}
}
void Destroy_List(DuLinkList* plist) {
    //销毁链表
	assert(plist != nullptr);
	Clear_List(plist);
	Freenode(plist->head);
	plist->head = nullptr;
}
```

## 1.3栈

简单来说，栈是操作受限的线性表。其规定只能从数据的一端进行删除和插入，由于这样的特性，对于栈的入栈和出栈时间复杂度均为常数级，相对于普通的线性表时间复杂度低。

### 1.3.1顺序栈

#### 头文件（Stack.h）

```c
//"Stack.h"
#pragma once
#include<stdio.h>
#include<stdlib.h>
#include<assert.h>
#define INITSIZE 10
typedef int ElemType;
typedef struct Stack {
	ElemType* base;
	int top;//栈顶指针
	int stacksize;
}Stack, * pStack;
//顺序栈
void Init_Stack(pStack pstack);//初始化栈
bool Push(pStack pstack, ElemType val);//入栈
bool Pop(pStack pstack, ElemType* e);//出栈，并获取出栈元素的值
bool Get_Top(pStack pstack, ElemType* e);//获取栈顶元素的值
int Get_Length(pStack pstack);//获取当前有效元素的个数
bool IsEmpty(pStack pstack);//判空
bool IsFull(pStack pstack);//判满
static void Inc(pStack pstack);//如果栈满，则进行扩容
void Clear(pStack pstack);//清空栈
void Destroy(pStack pstack);//销毁栈
void Print_Stack(pStack pstack);//打印栈
```

#### 源文件

```c
#include"Stack.h"

void Init_Stack(pStack pstack) {
	assert(pstack != nullptr);
	if (pstack == nullptr)return;
	pstack->base = (ElemType*)malloc(sizeof(ElemType) * INITSIZE);
	if (pstack->base == nullptr) {
		printf("malloc filed\n");
		exit(EXIT_FAILURE);
	}
	pstack->top = 0;//栈顶指针指向将要插入元素的位置
	pstack->stacksize = INITSIZE;
}
bool Push(pStack pstack, ElemType e) {
	assert(pstack != nullptr);
	if (pstack == nullptr)return false;
	if (IsFull(pstack)) {
		Inc(pstack);
	}
	pstack->base[pstack->top] = e;//首先向栈顶指针指向的位置插入元素
	pstack->top += 1;//再将栈顶指针的位置加一
	return true;
}
bool Pop(pStack pstack, ElemType* e) {
	assert(pstack != nullptr);
	if (pstack == nullptr)return false;
	if (IsEmpty(pstack)) {
		printf("empty stack\n");
		return false;
	}	
	pstack->top -= 1;//将栈顶指针的位置减一
	*e = pstack->base[pstack->top];//再获取出栈元素的数值
	return true;
}
bool Get_Top(pStack pstack, ElemType* e) {
	assert(pstack != nullptr);
	if (pstack == nullptr)return false;
	if (IsEmpty(pstack)) {
		printf("empty stack\n");
		return false;
	}
	*e = pstack->base[pstack->top - 1];//注意这里没有更改栈顶指针的位置
	return true;
}
int Get_Length(pStack pstack) {
	assert(pstack != nullptr);
	if (pstack == nullptr)return false;
	return pstack->top;
}
bool IsEmpty(pStack pstack) {
	return pstack->top == 0;
}
bool IsFull(pStack pstack) {
	return pstack->top == pstack->stacksize;
}
static void Inc(pStack pstack) {
	ElemType* pnew = (ElemType*)realloc(pstack->base, sizeof(ElemType) * pstack->stacksize * 2);
	if (pnew == nullptr) {
		printf("realloc filed\n");
		exit(EXIT_FAILURE);
	}
	pstack->base = pnew;
	pstack->stacksize *= 2;
}
void Clear(pStack pstack) {
	assert(pstack != nullptr);
	if (pstack == nullptr)return;
	pstack->top = 0;
}
void Destroy(pStack pstack) {
	assert(pstack != nullptr);
	if (pstack == nullptr)return;
	Clear(pstack);
	free(pstack->base);
	pstack->base = nullptr;
	pstack->top = 0;
	pstack->stacksize = 0;
	printf("stack is already destroyed\n");
}
void Print_Stack(pStack pstack) {
	assert(pstack != nullptr);
	if (pstack == nullptr)return;
	for (int i = 0;i < pstack->top;i++) {
		printf("%d ", pstack->base[i]);
	}
	printf("\n");
}
//int main() {
//	Stack mystack;
//	Init_Stack(&mystack);
//	for (int i = 0;i < 20;i++) {
//		Push(&mystack, i);
//	}
//	Print_Stack(&mystack);
//	int tmp1;
//	Get_Top(&mystack, &tmp1);
//	printf("%d\n", tmp1);
//	Print_Stack(&mystack);
//	int tmp2;
//	Pop(&mystack, &tmp2);
//	printf("%d\n", tmp2);
//	Print_Stack(&mystack);
//	printf("length = %d\n", Get_Length(&mystack));
//	Clear(&mystack);
//	printf("length = %d\n", Get_Length(&mystack));
//	Destroy(&mystack);
//}
```

### 1.3.2链栈

#### 头文件（LStack.h）

```c
//"LStack.h"
#pragma once
#include<stdio.h>
#include<stdlib.h>
#include<assert.h>
typedef int ElemType;
typedef struct LStack {
	ElemType data;
	struct LStack* next;
}LStack, * pLStack;
//链栈
void Init_Stack(pLStack pstack);//初始化栈
bool Push(pLStack pstack, ElemType val);//入栈
bool Pop(pLStack pstack, ElemType* e);//出栈，并获取出栈元素的值
bool Get_Top(pLStack pstack, ElemType* e);//获取栈顶元素的值
int Get_Length(pLStack pstack);//获取当前有效元素的个数
bool IsEmpty(pLStack pstack);//判空
void Clear(pLStack pstack);//清空栈
void Destroy(pLStack& pstack);//销毁栈
void Print_Stack(pLStack pstack);//打印栈
```



#### 源文件

```c
#include"LStack.h"

void Init_Stack(pLStack plstack) {
	assert(plstack != nullptr);
	if (plstack == nullptr)return;
	plstack->next = nullptr;
}
bool Push(pLStack plstack, ElemType val) {
	assert(plstack != nullptr);
	if (plstack == nullptr)return false;
	LStack* p = (LStack*)malloc(sizeof(LStack));//申请新的结点
	if (p == nullptr)return false;
	p->data = val;
	p->next = plstack->next;//头插方式入栈
	plstack->next = p;
	return true;
}
bool Pop(pLStack plstack, ElemType* e) {
	assert(plstack != nullptr);
	if (plstack == nullptr)return false;
	if (IsEmpty(plstack)) {
		printf("empty stack\n");
		return false;
	}
	*e = plstack->next->data;
	LStack* p = plstack->next;//释放头结点后的第一个结点视为出栈
	plstack->next = p->next;
	free(p);
	p = nullptr;
	return true;
}
bool Get_Top(pLStack plstack, ElemType* e) {
	assert(plstack != nullptr);
	if (plstack == nullptr)return false;
	if (IsEmpty(plstack)) {
		printf("empty stack\n");
		return false;
	}
	*e = plstack->next->data;
	return true;
}
int Get_Length(pLStack plstack) {
	int count = 0;
	LStack* p = plstack->next;
	while (p != nullptr) {
		count += 1;
		p = p->next;
	}
	return count;
}
bool IsEmpty(pLStack plstack) {
	return plstack->next == nullptr;
}
void Clear(pLStack plstack) {
	assert(plstack != nullptr);
	if (plstack == nullptr)return;
	while (plstack->next != nullptr) {
		LStack* p = plstack->next;
		plstack->next = p->next;
		free(p);
		p = nullptr;
	}
}
void Destroy(pLStack& plstack) {
	assert(plstack != nullptr);
	if (plstack == nullptr)return;
	Clear(plstack);
	free(plstack);
	plstack = nullptr;
	printf("stack is already destroyed\n");
}
void Print_Stack(pLStack plstack) {
	assert(plstack != nullptr);
	if (plstack == nullptr)return;
	LStack* p = plstack->next;
	while (p != nullptr) {
		printf("%d ", p->data);
		p = p->next;
	}
	printf("\n");
}
//int main() {
//	pLStack ls = (pLStack)malloc(sizeof(LStack));
//	if (ls == nullptr)exit(EXIT_FAILURE);
//	Init_Stack(ls);
//	for (int i = 0;i < 10;i++) {
//		Push(ls, i + 1);
//	}
//	Print_Stack(ls);
//	int tmp1;
//	Get_Top(ls, &tmp1);
//	printf("top->%d\n", tmp1);
//	int tmp2;
//	Pop(ls, &tmp2);
//	printf("pop->%d\n", tmp2);
//	Print_Stack(ls);
//	Destroy(ls);
//}
```

## 1.4队列

队列允许对队头和队尾进行出队和入队操作。

### 1.4.1循环队列（顺序队列）

#### 头文件（Queue.h）

```c
//"Queue.h"
#pragma once
#include<stdio.h>
#include<stdlib.h>
#include<assert.h>
#define MAXSIZE 5
typedef int ELEM_TYPE;
typedef struct Queue {
	ELEM_TYPE* base;
	int front;//队头指针
	int rear;//队尾指针
}Queue, * pQueue;
//顺序队列
void Init_Queue(pQueue pqueue);//初始化队列
bool En_Queue(pQueue pqueue, ELEM_TYPE val);//入队
bool De_Queue(pQueue pqueue, ELEM_TYPE* e);//出队，并获取出队元素的值
int Get_Length(pQueue pqueue);//获取当前有效元素的个数
bool Get_Front(pQueue pqueue, ELEM_TYPE* e);//获取队头元素的值
bool Get_Rear(pQueue pqueue, ELEM_TYPE* e);//获取队尾元素的值
bool IsEmpty(pQueue pqueue);//判空
bool IsFull(pQueue pqueue);//判满
void Clear(pQueue pqueue);//清空队列
void Destroy(pQueue pqueue);//销毁队列
void Print_Queue(pQueue pqueue);//打印队列
```

#### 源文件

```c
#include"Queue.h"

void Init_Queue(pQueue pqueue) {
	assert(pqueue != nullptr);
	if (pqueue == nullptr)return;
	pqueue->base = (ELEM_TYPE*)malloc(sizeof(ELEM_TYPE) * MAXSIZE);
	if (pqueue->base == nullptr) {
		printf("malloc failed\n");
		exit(EXIT_FAILURE);
	}
	pqueue->front = 0;
	pqueue->rear = 0;
}
bool En_Queue(pQueue pqueue, ELEM_TYPE val) {
	assert(pqueue != nullptr);
	if (pqueue == nullptr)return false;
	if (IsFull(pqueue)) {
		printf("queue is full\n");
		return false;
	}
	pqueue->base[pqueue->rear] = val;
	pqueue->rear = (pqueue->rear + 1) % MAXSIZE;
	return true;
}
bool De_Queue(pQueue pqueue, ELEM_TYPE* e) {
	assert(pqueue != nullptr);
	if (pqueue == nullptr)return false;
	if (IsEmpty(pqueue)) {
		printf("queue is empty\n");
		return false;
	}
	*e = pqueue->base[pqueue->front];
	pqueue->front = (pqueue->front + 1) % MAXSIZE;
	return true;
}
int Get_Length(pQueue pqueue) {
	assert(pqueue != nullptr);
	if (pqueue == nullptr)return false;
	int tmp = (pqueue->rear - pqueue->front + MAXSIZE) % MAXSIZE;
	return tmp;
}
bool Get_Front(pQueue pqueue,ELEM_TYPE* e) {
	assert(pqueue != nullptr);
	if (pqueue == nullptr)return false;
	if (IsEmpty(pqueue)) {
		printf("queue is empty\n");
		return false;
	}
	*e = pqueue->base[pqueue->front];
	return true;
}
bool Get_Rear(pQueue pqueue,ELEM_TYPE* e) {
	assert(pqueue != nullptr);
	if (pqueue == nullptr)return false;
	if (IsEmpty(pqueue)) {
		printf("queue is empty\n");
		return false;
	}
	*e = pqueue->base[(pqueue->rear - 1 + MAXSIZE) % MAXSIZE];
	return true;
}
bool IsEmpty(pQueue pqueue) {
	return pqueue->rear == pqueue->front;
}
bool IsFull(pQueue pqueue) {
	return (pqueue->rear + 1) % MAXSIZE == pqueue->front;
}
void Print_Queue(pQueue pqueue) {
	assert(pqueue != nullptr);
	if (pqueue == nullptr)return;
	int length = Get_Length(pqueue);
	for (int i = 0;i < length;i++) {
		printf("%d ", pqueue->base[(pqueue->front + i) % MAXSIZE]);
	}
	printf("\nqueue length = %d\n", length);
}
void Clear(pQueue pqueue) {
	assert(pqueue != nullptr);
	if (pqueue == nullptr)return;
	pqueue->front = pqueue->rear = 0;
}
void Destroy(pQueue pqueue) {
	assert(pqueue != nullptr);
	if (pqueue == nullptr)return;
	Clear(pqueue);
	free(pqueue->base);
	pqueue->base = nullptr;
	pqueue->rear = 0;
	pqueue->front = 0;
	printf("queue is already destroyed\n");
}
//int main() {
//	Queue myq;
//	Init_Queue(&myq);
//	for (int i = 0;i < 4;i++) {
//		En_Queue(&myq, i + 1);
//	}
//	Print_Queue(&myq);
//	int e;
//	De_Queue(&myq, &e);
//	Print_Queue(&myq);
//	int a1, a2;
//	Get_Front(&myq, &a1);
//	Get_Rear(&myq, &a2);
//	printf("front is %d,rear is %d\n", a1, a2);
//	En_Queue(&myq, 1);
//	Print_Queue(&myq);
//	Get_Front(&myq, &a1);
//	Get_Rear(&myq, &a2);
//	printf("front is %d,rear is %d\n", a1, a2);
//	Clear(&myq);
//	Print_Queue(&myq);
//	Destroy(&myq);
//}
```

### 1.4.2链队列

#### 头文件（LQueue.h）

```c
//"LQueue.h"
#pragma once
#include<stdio.h>
#include<stdlib.h>
#include<assert.h>

typedef int ELEM_TYPE;
typedef struct Node {
	ELEM_TYPE data;
	struct Node* next;
}Node, * PNode;
typedef struct Head {
	struct Node* front;
	struct Node* rear;
	//int length;
}Head, * PHead;
//链队列
void Init_Lqueue(PHead phead);//初始化队列
bool En_LQueue(PHead phead, ELEM_TYPE val);//入队
bool De_LQueue(PHead phead, ELEM_TYPE* e);//出队
bool Get_Top(PHead phead, ELEM_TYPE* e);//获取队列顶部元素
int Get_Length(PHead phead);//获取其有效元素个数
bool IsEmpty(PHead phead);//判空
void Clear(PHead phead);//清空队列
void Destroy(PHead phead);//销毁队列
void Print(PHead phead);//打印队列
```

#### 源文件

```c
#include"LQueue.h"

void Init_Lqueue(PHead phead) {
	//初始化
	assert(phead != nullptr);
	if (phead == nullptr)return;
	phead->front = nullptr;
	phead->rear = nullptr;
}

bool En_LQueue(PHead phead, ELEM_TYPE val) {
	//入队
	assert(phead != nullptr);
	if (phead == nullptr)return false;
	Node* p = (Node*)malloc(sizeof(Node));
	if (p == nullptr) {
		printf("malloc failed\n");
		return false;
	}
	p->data = val;
	if (phead->front == nullptr) {
		//插入第一个元素
		p->next = nullptr;
		phead->front = p;
		phead->rear = p;
	}
	else {
		//不是第一个元素
		p->next = phead->rear->next;
		phead->rear->next = p;
		phead->rear = p;
	}
	return true;
}

bool De_LQueue(PHead phead, ELEM_TYPE* e) {
	//出队
	assert(phead != nullptr && e != nullptr);
	if (phead == nullptr || e == nullptr)return false;
	if (IsEmpty(phead)) {
		printf("queue is empty\n");
		return false;
	}
	if (phead->front->next == nullptr) {
		//只有一个元素
		Node* p = phead->front;
		*e = p->data;
		free(p);
		p = nullptr;
		phead->front = phead->rear = nullptr;
	}
	else {
		//不止一个元素
		Node* p = phead->front;
		*e = p->data;
		phead->front = p->next;
		free(p);
		p = nullptr;
	}
	return true;
}

bool Get_Top(PHead phead, ELEM_TYPE* e) {
	//获取队列顶部元素
	assert(phead != nullptr && e != nullptr);
	if (phead == nullptr || e == nullptr)return false;
	if (IsEmpty(phead)) {
		printf("queue is empty\n");
		return false;
	}
	*e = phead->front->data;
	return true;
}

int Get_Length(PHead phead) {
	//获取其有效元素个数
	assert(phead != nullptr);
	if (phead == nullptr)return false;
	int count = 0;
	Node* p = phead->front;
	for (p;p != nullptr;p = p->next) {
		count++;
	}
	return count;
}

bool IsEmpty(PHead phead) {
	//判空
	return phead->front == nullptr;
}

void Clear(PHead phead) {
	//清空
	assert(phead != nullptr);
	if (phead == nullptr)return;
	while (phead->front != nullptr) {
		Node* p = phead->front;
		phead->front = p->next;
		free(p);
		p = nullptr;
	}
	phead->front = nullptr;
	phead->rear = nullptr;
}

void Print(PHead phead) {
	//打印
	assert(phead != nullptr);
	if (phead == nullptr)return;
	Node* p = phead->front;
	for (p;p != nullptr;p = p->next) {
		printf("%d ", p->data);
	}
	printf("\n");
}

//int main() {
//	Head myhead;
//	Init_Lqueue(&myhead);
//	for (int i = 0;i < 20;i++) {
//		En_LQueue(&myhead, i + 1);
//	}
//	Print(&myhead);
//	int e = 0;
//	De_LQueue(&myhead, &e);
//	Print(&myhead);
//	printf("top->%d length = %d\n", e, Get_Length(&myhead));
//	Get_Top(&myhead, &e);
//	Print(&myhead);
//	printf("top->%d length = %d\n", e, Get_Length(&myhead));
//	Clear(&myhead);
//	return 0;
//}
```

## 1.5哈希表

哈希描述数据存储的一种方式。对每一个存入的数据，通过哈希函数计算得到对应的存储位置，所以原本数据中存在的顺序关系和哈希表中数据的顺序无关。理想状态是元素和存储位置之间构成单射，即每一个元素都有唯一确定存储位置，每一个存储位置对应唯一确定的元素，这样在查询操作时，用户输入查询元素，通过哈希函数的映射关系，可以立刻唯一确定其位置。在一般情况下，多个元素经过哈希函数计算后可能得到相同的值，由于一个存储位置只能存储一个元素，所以需要调整冲突元素的存储位置。对于顺序存储方式来说，通过向后偏移数据来实现；对于链式存储方式来说，冲突元素通过链表的方式连接在对应存储位置后面。下面给出链式哈希的操作代码参考。

#### 头文件（Hash.h）

```c
//"Hash.h"
#pragma once
#include<stdio.h>
#include<stdlib.h>
#include<assert.h>
#define HASHSIZE 12

typedef int ELEM_TYPE;
typedef struct Node {
	ELEM_TYPE data;
	struct Node* next;
}Node, * PNode;
typedef struct Hash {
	struct Node arr[HASHSIZE];
}Hash, * PHash;
//链式哈希
void Init_Hash(PHash phash);//初始化
bool Insert_Hash(PHash phash, ELEM_TYPE key);//插入
bool Del_Hash(PHash phash, ELEM_TYPE key);//删除
Node* Search(PHash phash, ELEM_TYPE key);//查找
void Print_Hash(PHash phash);//打印
```

#### 源文件

```c
#include"Hash.h"

void Init_Hash(PHash phash) {
	assert(phash != nullptr);
	if (phash == nullptr)return;
	for (int i = 0;i < HASHSIZE;i++) {
		phash->arr[i].next = nullptr;
	}
}

bool Insert_Hash(PHash phash, ELEM_TYPE key) {
	assert(phash != nullptr);
	if (phash == nullptr)return false;
	ELEM_TYPE hash = key % HASHSIZE;
	Node* p = (Node*)malloc(sizeof(Node));
	if (p == nullptr) {
		printf("malloc failed\n");
		return false;
	}
	p->data = key;
	//头插法
	p->next = phash->arr[hash].next;
	phash->arr[hash].next = p;
	return true;
}

bool Del_Hash(PHash phash, ELEM_TYPE key) {
	assert(phash != nullptr);
	if (phash == nullptr)return false;
	ELEM_TYPE hash = key % HASHSIZE;
	Node* p = &phash->arr[hash];
	for (p;p->next != nullptr;p = p->next) {
		if (p->next->data == key) {
			Node* q = p->next;
			p->next = q->next;
			free(q);
			q = nullptr;
			return true;
		}
	}
	return false;
}

Node* Search(PHash phash, ELEM_TYPE key) {
	ELEM_TYPE hash = key % HASHSIZE;
	Node* p = phash->arr[hash].next;
	for (p;p != nullptr;p = p->next) {
		if (p->data == key) {
			return p;
		}
	}
	return nullptr;
}

void Print_Hash(PHash phash) {
	for (int i = 0;i < HASHSIZE;i++) {
		printf("%3d: ", i);
		Node* p = phash->arr[i].next;
		for (p;p != nullptr;p = p->next) {
			printf("%d ", p->data);
		}
		printf("\n");
	}
}
//int main() {
//	Hash myhash;
//	Init_Hash(&myhash);
//	int ar[12] = { 13,32,65,82,29,56,19,4,78,47,55,37 };
//	for (int i = 0;i < 12;i++) {
//		Insert_Hash(&myhash, ar[i]);
//	}
//	Print_Hash(&myhash);
//	Node* p = Search(&myhash, 78);
//	printf("data: %d\n", p->data);
//	Del_Hash(&myhash, 19);
//	Print_Hash(&myhash);
//}
```

## 1.6栈和队列的应用

### 1.6.1两个栈实现队列

使用已经完成的顺序栈来实现队列的功能。顺序栈拥有扩容函数，所以构成的队列不需要考虑判满，受限于实现方式，构成的队列难以实现打印操作。

#### 头文件（Stack_To_Queue.h）

```c
//"Stack_To_Queue.h"
#pragma once
#include"Stack.h"

typedef struct Stack_To_Queue {
	Stack stack1;//每次入队时向stack1入栈
	Stack stack2;//每次出队时向stack2出栈，如果stack2为空，
				//则将stack1元素装入stack2中，再向stack2出栈
}stq, * pstq;
//两个栈实现一个队列
void my_Init_Queue(pstq pqueue);//初始化队列
bool my_En_Queue(pstq pqueue, ElemType val);//入队
bool my_De_Queue(pstq pqueue, ElemType* e);//出队，并获取出队元素的值
bool my_Get_Top(pstq pqueue, ElemType* e);//获取队头元素的值
bool my_IsEmpty(pstq pqueue);//判空
int my_Get_Length(pstq pqueue);///获取当前有效元素个数
void my_Clear(pstq pqueue);//清空队列
void my_Destroy(pstq pqueue);//销毁队列
```

#### 源文件

```c
#include"Stack_To_Queue.h"

void my_Init_Queue(pstq pqueue) {
	assert(pqueue != nullptr);
	if (pqueue == nullptr)return;
	Init_Stack(&pqueue->stack1);
	Init_Stack(&pqueue->stack2);
}
bool my_En_Queue(pstq pqueue, ElemType val) {
	assert(pqueue != nullptr);
	if (pqueue == nullptr) {
		printf("Push failed\n");
		return false;
	}
	Push(&pqueue->stack1, val);//入队操作均对栈1进行入栈
	return true;
}
bool my_De_Queue(pstq pqueue, ElemType* e) {
	assert(pqueue != nullptr && e != nullptr);
	if (pqueue == nullptr || e == nullptr) {
		printf("Pop failed\n");
		return false;
	}
	if (my_IsEmpty(pqueue)) {
		printf("This is an empty stack\n");
		return false;
	}
	if (IsEmpty(&pqueue->stack2)) {//如果栈2为空
		while (!IsEmpty(&pqueue->stack1)) {//将栈1中的所有元素转移到栈2
			ElemType tmp;
			Pop(&pqueue->stack1, &tmp);
			Push(&pqueue->stack2, tmp);
		}
	}
	return Pop(&pqueue->stack2, e);//从栈2中出栈，实现出队的操作
}
bool my_Get_Top(pstq pqueue, ElemType* e) {
	assert(pqueue != nullptr && e != nullptr);
	if (pqueue == nullptr || e == nullptr) {
		printf("Get_Top failed\n");
		return false;
	}
	if (my_IsEmpty(pqueue)) {
		printf("This is an empty stack\n");
		return false;
	}
	if (IsEmpty(&pqueue->stack2)) {
		while (!IsEmpty(&pqueue->stack1)) {
			ElemType tmp;
			Pop(&pqueue->stack1, &tmp);
			Push(&pqueue->stack2, tmp);
		}
	}
	return Get_Top(&pqueue->stack2, e);
    
}
bool my_IsEmpty(pstq pqueue) {
	bool flag = false;
	if (IsEmpty(&pqueue->stack1) && IsEmpty(&pqueue->stack2)) {
		flag = true;
	}
	return flag;
}
int my_Get_Length(pstq pqueue) {
	return Get_Length(&pqueue->stack1) + Get_Length(&pqueue->stack2);

}
void my_Clear(pstq pqueue) {
	Clear(&pqueue->stack1);
	Clear(&pqueue->stack2);
}
void my_Destroy(pstq pqueue) {
	Destroy(&pqueue->stack1);
	Destroy(&pqueue->stack2);
}

//int main() {
//	ElemType value1;
//	ElemType value2;
//	stq mystq;
//
//	my_Init_Queue(&mystq);
//	my_De_Queue(&mystq, &value1);
//	for (int i = 0; i < 10; i++) {
//		my_En_Queue(&mystq, i + 1);
//	}
//
//	my_Get_Top(&mystq, &value1);
//	printf("Top value is %d,", value1);
//	printf("current length is %d\n", my_Get_Length(&mystq));
//
//	for (int i = 0;i < 3;i++) {
//		my_De_Queue(&mystq, &value2);
//		printf("Pop value is %d,", value2);
//		printf("current length is %d\n", my_Get_Length(&mystq));
//	}
//
//	my_Get_Top(&mystq, &value1);
//	printf("Top value is %d,", value1);
//	printf("current length is %d\n", my_Get_Length(&mystq));
//	return 0;
//}
```

### 1.6.2两个队列实现栈

通过已经完成的循环队列来实现栈的功能。由于循环队列设置为固定长度，所以构成的栈的最大长度为一个队列的最大长度，需要注意的是，在不执行操作的时候，两个队列应该只有一个队列存在元素。

#### 头文件（Queue_To_Stack.h）

```c
//"Queue_To_Stack.h"
#pragma once
#include"Queue.h"

typedef struct Queue_To_Stack {
	Queue queue1;
	Queue queue2;
}qts, * pqts;
//两个队列实现一个栈
void my_Init_Stack(pqts pstack);//初始化栈
bool my_Push(pqts pstack, ELEM_TYPE val);//入栈
bool my_Pop(pqts pstack, ELEM_TYPE* e);//出栈，并获取出栈元素的值
bool my_Get_Top(pqts pstack, ELEM_TYPE* e);//获取栈顶元素的值
int my_Get_Length(pqts pstack);//获取当前有效元素的个数
bool my_IsEmpty(pqts pstack);//判空
bool my_IsFull(pqts pstack);//判满
void my_Clear(pqts pstack);//清空栈
void my_Destroy(pqts pstack);//销毁栈
void my_Print_Stack(pqts pstack);//打印栈
```

#### 源文件

```c
#include"Queue_To_Stack.h"

void my_Init_Stack(pqts pstack) {
	//初始化栈
	assert(pstack != nullptr);
	if (pstack == nullptr)return;
	Init_Queue(&pstack->queue1);
	Init_Queue(&pstack->queue2);
}
bool my_Push(pqts pstack, ELEM_TYPE val) {
	//入栈
	assert(pstack != nullptr);
	if (pstack == nullptr)return false;
	if (my_IsFull(pstack)) {
		printf("Stack is full\n");
		return false;
	}
	if (!IsEmpty(&pstack->queue1)) {//如果队列1不空
		return En_Queue(&pstack->queue1, val);//向队列1入队
	}
	else {
		return En_Queue(&pstack->queue2, val);//否则向队列2入队
	}
}
bool my_Pop(pqts pstack, ELEM_TYPE* e) {
	//出栈，并获取出栈元素的值
	assert(pstack != nullptr && e != nullptr);
	if (pstack == nullptr || e == nullptr) {
		printf("Pop failed\n");
		return false;
	}
	if (my_IsEmpty(pstack)) {
		printf("This is an empty stack\n");
		return false;
	}	
	ELEM_TYPE tmp;
	if (!IsEmpty(&pstack->queue1)) {//如果队列1不空
		int size = Get_Length(&pstack->queue1);
		while (size > 1) {//队列1出队，并向队列2入队，直到队列1剩余最后一个元素
			De_Queue(&pstack->queue1, &tmp);
			En_Queue(&pstack->queue2, tmp);
			size -= 1;
		}
		return De_Queue(&pstack->queue1, e);//将队列1最后一个元素出队，实现出栈的操作
	}
	else {//队列2不空同理
		int size = Get_Length(&pstack->queue2);
		while (size > 1) {
			De_Queue(&pstack->queue2, &tmp);
			En_Queue(&pstack->queue1, tmp);
			size -= 1;
		}
		return De_Queue(&pstack->queue2, e);
	}
}
bool my_Get_Top(pqts pstack, ELEM_TYPE* e) {
	//获取栈顶元素的值
	assert(pstack != nullptr && e != nullptr);
	if (pstack == nullptr || e == nullptr) {
		printf("Get_top failed\n");
		return false;
	}
	if (my_IsEmpty(pstack)) {
		printf("This is an empty stack\n");
		return false;
	}
	if (!IsEmpty(&pstack->queue1)) {//队列1不空
		return Get_Rear(&pstack->queue1, e);//获取队尾元素，这个元素就是需要的栈顶元素
	}
	else {
		return Get_Rear(&pstack->queue2, e);
	}
}
int my_Get_Length(pqts pstack) {
	//获取当前有效元素的个数
	return Get_Length(&pstack->queue1) + Get_Length(&pstack->queue2);
}
bool my_IsEmpty(pqts pstack) {
	//判空
	return IsEmpty(&pstack->queue1) && IsEmpty(&pstack->queue2);
}
bool my_IsFull(pqts pstack) {
	//判满
	if (!IsEmpty(&pstack->queue1)) {
		return IsFull(&pstack->queue1);
	}
	return IsFull(&pstack->queue2);
}
void my_Clear(pqts pstack) {
	//清空栈
	Clear(&pstack->queue1);
	Clear(&pstack->queue2);
}
void my_Destroy(pqts pstack) {
	//销毁栈
	Destroy(&pstack->queue1);
	Destroy(&pstack->queue2);
}
void my_Print_Stack(pqts pstack) {
	//打印栈
	assert(pstack != nullptr);
	if (pstack == nullptr) {
		printf("print failed\n");
		return;
	}
	if (!IsEmpty(&pstack->queue1)) {
		Print_Queue(&pstack->queue1);
	}
	else {
		Print_Queue(&pstack->queue2);
	}
}

//int main() {
//	qts mystack;
//	my_Init_Stack(&mystack);
//	for (int i = 0;i < 4;i++) {
//		my_Push(&mystack, i + 10);
//	}
//	my_Print_Stack(&mystack);
//	ELEM_TYPE e = -1;
//	my_Pop(&mystack, &e);
//	printf("\npop->%d\n", e);
//	my_Print_Stack(&mystack);
//	my_Get_Top(&mystack, &e);
//	printf("\ntop->%d\n", e);
//	my_Print_Stack(&mystack);
//	my_Clear(&mystack);
//	my_Print_Stack(&mystack);
//	my_Destroy(&mystack);
//	return 0;
//}
```

# 2.串

串主要针对字符串而言，常见的有字符串操作有拷贝、拼接、比较、长度等，这里主要介绍另一种字符串的使用：字符串匹配。意思是存在一个主串，对于用户给出的任何子串，函数都可以得到该子串在主串当中的位置（如果不存在该子串，则返回失败）。

## 2.1朴素算法

朴素算法，也叫BF算法，实现原理简单易懂，缺点是时间复杂度高，如果主串长度为N，子串的长度为M，那么时间复杂度为O(N*M)。

```c
int BF_Search(const char* str, const char* sub, int pos) {
	assert(str != nullptr && sub != nullptr && pos >= 0 && pos < strlen(str));
	if (str == nullptr || sub == nullptr || pos < 0 || pos >= strlen(str)) {
		printf("Search failed\n");
		return -1;
	}

	int lenstr = strlen(str);//主串的长度
	int lensub = strlen(sub);//子串的长度
	int i = pos;//主串匹配时的下标
	int j = 0;//子串匹配时的下标
	while (i < lenstr && j < lensub) {
		if (str[i] == sub[j]) {
			i++;
			j++;
		}
		else {//匹配不成功时
			i = i - j + 1;//主串指针回退到本次匹配开始位置的下一个位置
			j = 0;//子串指针回退到开头
		}
	}

	if (j >= lensub) {//如果子串与主串成功匹配
		return i - j;//返回子串在主串中的位置
	}
	else {
		printf("Can't find str : \"%s\"\n", sub);
		return -1;
	}
}
```

## 2.2KMP算法

在KMP算法中，主串指针一定不回退，并且子串的回退位置根据next数组确定，其中next数组是由也子串唯一确定的。

```c
int* Get_Next(const char* sub) {
	int lensub = strlen(sub);
	int* next = (int*)malloc(sizeof(int) * lensub);
	assert(next != nullptr);

	//默认值设定
	next[0] = -1;
	next[1] = 0;

	int j = 1;
	int k = 0;

	while (j + 1 < lensub) {//获取next数组
		if ((k == -1) || sub[j] == sub[k]) {
			k++;
			j++;
			next[j] = k;
		}
		else {
			k = next[k];
		}
	}
	return next;
}

int KMP_Search(const char* str, const char* sub, int pos) {
	assert(str != nullptr && sub != nullptr && pos >= 0 && pos < strlen(str));
	if (str == nullptr || sub == nullptr || pos < 0 || pos >= strlen(str)) {
		printf("Search failed\n");
		return -1;
	}

	int lenstr = strlen(str);//主串的长度
	int lensub = strlen(sub);//子串的长度
	int i = pos;//主串匹配时的下标
	int j = 0;//子串匹配时的下标

	int* next = Get_Next(sub);//得到当前子串的next数组

	while (i < lenstr && j < lensub) {
		if ((j == -1) || str[i] == sub[j]) {
			i++;
			j++;
		}
		else {//匹配不成功时
			j = next[j];//子串指针根据next数组回退到相应的位置
		}
	}

	if (j >= lensub) {
		return i - j;
	}
	else {
		printf("can't find str : \"%s\"\n", sub);
		return -1;
	}
}
```

# 3.排序算法

八大排序算法：选择排序，插入排序，希尔排序，冒泡排序，归并排序，基数排序，堆排序，快速排序。
稳定的算法：插入排序，冒泡排序，归并排序，基数排序。
不稳定的算法：选择排序，希尔排序，快速排序，堆排序。

## 3.1插入排序

插入排序的思路是认为存在一个有序序列（开始时只有首元素），每一次循环将不在这个序列里的一个元素通过比较相邻元素然后交换的方式插入到该序列的合适位置，从而使得这个有序序列不断增加，直到所有元素都在这个序列当中时，排序完成。

```c
void Insert_Sort(int* arr, int len) {
	assert(arr != NULL);
	if (arr == NULL) {
		printf("insert failed\n");
		return;
	}
	int tmp, j;
	for (int i = 1; i < len; i++) {
		tmp = arr[i];
		for (j = i - 1; j >= 0; j--) {
			if (arr[j] > tmp) {
				arr[j + 1] = arr[j];
			}
			else {
				break;
			}
		}
		arr[j + 1] = tmp;
	}
}
```

## 3.2希尔排序

希尔排序可以说是插入排序的升级版本，加入了希尔函数，即所谓的“步长”，本质上采用的还是插入排序的思路。

```c
static void shell(int* arr, int len, int gap) {
	int tmp, j;
	for (int i = gap; i < len; i++)	{
		tmp = arr[i];
		for (j = i - gap; j >= 0; j = j - gap) {
			if (arr[j] > tmp) {
				arr[j + gap] = arr[j];
			}
			else {
				break;
			}
		}
		arr[j + gap] = tmp;
	}
}
void Shell_Sort(int* arr, int len) {
	assert(arr != nullptr);
	if (arr == nullptr) {
		printf("shell failed\n");
		return;
	}
	int gap[] = { 5, 3, 1 };
	int lengap = sizeof(gap) / sizeof(gap[0]);
	for (int i = 0; i < lengap; i++) {
		shell(arr, len, gap[i]);
	}
}
```

## 3.3冒泡排序

简单的排序算法之一，双重 for 循环完成对数组的遍历并且排序，增加标记位判断每次遍历是否交换元素可以提高排序的效率。

```c
void Bubble_Sort(int* arr, int len) {
    assert(arr != nullptr);
	if (arr == nullptr) {
		printf("bubble failed\n");
		return;
	}
	bool tag = true;
	for (int i = 0; i < len - 1; i++) {
		tag = true;
		for (int j = 0; j < len - i - 1; j++) {
			if (arr[j] > arr[j + 1]) {
				tag = false;
				int tmp = arr[j];
				arr[j] = arr[j + 1];
				arr[j + 1] = tmp;
			}
		}
		if (tag) {
			break;
		}
	}
}
```

## 3.4选择排序

选择排序的思路是认为存在一个有序序列（开始时没有元素在其中），每一次循环都会从非有序序列中寻找一个键值最小的加入到有序序列中，直到排定所有元素为止。

```c
void Select_Sort(int* arr, int len) {
	assert(arr != nullptr);
	if (arr == nullptr) {
		printf("select failed\n");
		return;
	}
	int minindex;
	for (int i = 0;i < len - 1;i++) {
		minindex = i;
		for (int j = i + 1;j < len;j++) {
			if (arr[j] < arr[minindex]) {
				minindex = j;
			}
		}
		if (i != minindex) {
			int tmp = arr[i];
			arr[i] = arr[minindex];
			arr[minindex] = tmp;
		}
	}
}
```

## 3.5归并排序

归并排序分步对待序列排序，每次将数据分成小组（开始时是两两比较），小组内有序后，按照2的幂扩大小组的规模，直到小组足以覆盖所有元素的时候，所有元素就被排定。

```c
static void merge(int* arr, int len, int step) {
	int low1, low2, high1, high2, i;
	int* brr = (int*)malloc(sizeof(int) * len);
	assert(brr != nullptr);

	i = 0;
	low1 = 0;
	high1 = low1 + step - 1;
	low2 = high1 + 1;
	high2 = low2 + step - 1 < len ? low2 + step - 1 : len - 1;

	while (low2 < len) {
		while (low1 <= high1 && low2 <= high2) {
			if (arr[low1] <= arr[low2]) {
				brr[i++] = arr[low1++];
			}
			else {
				brr[i++] = arr[low2++];
			}
		}
		while (low1 <= high1) {
			brr[i++] = arr[low1++];
		}
		while (low2 <= high2) {
			brr[i++] = arr[low2++];
		}
		low1 = high2 + 1;
		high1 = low1 + step - 1;
		low2 = high1 + 1;
		high2 = low2 + step - 1 < len ? low2 + step - 1 : len - 1;
	}

	while (low1 < len) {
		brr[i++] = arr[low1++];
	}
	for (int i = 0;i < len;i++) {
		arr[i] = brr[i];
	}
	free(brr);
	brr = nullptr;
}
void Merge_Sort(int* arr, int len) {
	assert(arr != nullptr);
	if (arr == nullptr) {
		printf("merge failed\n");
		return;
	}
	
	for (int i = 1;i < len;i *= 2) {
		merge(arr, len, i);
	}
}
```

## 3.6堆排序

堆排序使用完全二叉树的思想组织一个数组，在算法上实现堆有序，然后将堆中最大元素和最后一个结点交换，认为有序元素加一，交换仅针对无序元素，所以当全部无序元素交换完毕，全部元素有序。

```c
static void max_heapify(int* arr, int start, int end) {
	// 建立父结点下标和子结点下标
	int dad = start;
	int son = dad * 2 + 1;
	while (son <= end) { // 若子结点下标在范围内才比较
		if (son + 1 <= end && arr[son] < arr[son + 1]) // 先比较两个子结点大小，选择最大的
			son++;
		if (arr[dad] > arr[son]) // 如果父结点大于子结点代表调整完毕，直接跳出函数
			return;
		else { // 否则交换父子内容再继续子结点和孙结点比较
			swap(&arr[dad], &arr[son]);
			dad = son;
			son = dad * 2 + 1;
		}
	}
}
void Heap_sort(int* arr, int len) {
    assert(arr != nullptr);
	if (arr == nullptr) {
		printf("heap failed\n");
		return;
	}
    
	// 初始化，i从最后一个父结点开始调整
	for (int i = len / 2 - 1; i >= 0; i--)
		max_heapify(arr, i, len - 1);
	// 先将第一个元素和已排好前一位做交换，再重新调整，直到排序完毕
	for (int i = len - 1; i > 0; i--) {
		swap(&arr[0], &arr[i]);
		max_heapify(arr, 0, i - 1);
	}
}
```

## 3.7基数排序

基数排序利用数据每一位上的数字来排序，从个位开始，每一次都会排定一些元素，直到最高位结束，所有元素都有序。

```c
static int get_figure(int* arr, int len) {
	//获取最大位数
	int tmp = 0;
	for (int i = 0;i < len;i++) {
		if (arr[i] > tmp) {
			tmp = arr[i];
		}
	}
	int count = 0;
	while (tmp != 0) {
		count++;
		tmp /= 10;
	}
	return count;
}
static int get_num(int n, int fin) {
	//获取fin位的数字
	for (int i = 0;i < fin;i++) {
		n /= 10;
	}
	return n % 10;
}
static void radix(int* arr, int len, int fin) {
	int bucket[10][20] = { 0 };
	int num[10] = { 0 };
	for (int i = 0;i < len;i++) {
		int index = get_num(arr[i], fin);
		bucket[index][num[index]] = arr[i];
		num[index]++;
	}
	int k = 0;
	for (int i = 0;i < 10;i++) {
		for (int j = 0;j < num[i];j++) {
			arr[k++] = bucket[i][j];
		}
	}
}
void Radix_Sort(int* arr, int len) {
	assert(arr != nullptr);
	if (arr == nullptr) {
		printf("radix failed\n");
		return;
	}
	int count = get_figure(arr, len);
	for (int i = 0;i < count;i++) {
		radix(arr, len, i);
	}
}
```

## 3.8快速排序

快速排序首先选取一个元素，移动这个元素，使其左边的数据都不大于它，右边的数据都不小于它，也就是说这个元素在将来有序序列中的位置已经确定，这个操作叫做“划分”，可以看做这个元素将所有数据“一分为二”。递归是最常见的快速排序实现方式，还可以使用栈或者队列实现。

```c
static int partition(int* arr, int left, int right) {
	int tmp = arr[left];
	while (left < right) {
		while (left < right && arr[right] >= tmp)right--;
		arr[left] = arr[right];
		while (left < right && arr[left] <= tmp)left++;
		arr[right] = arr[left];
	}
	arr[left] = tmp;
	return left;
}
static void quick(int* arr, int left, int right) {
	if (left < right) {
		int par = partition(arr, left, right);
		quick(arr, left, par - 1);
		quick(arr, par + 1, right);
	}
}
void Quick_Sort(int* arr, int len) {
	assert(arr != nullptr);
	if (arr == nullptr) {
		printf("quick failed\n");
		return;
	}
	quick(arr, 0, len - 1);
}
```

# 4.递归与分治

将规模较大的问题分解成规模较小的问题是分治策略的基本思想。如果原问题可以被分解成若干个子问题，并且这些子问题均有解，那么这种分治法就是可行的。分治法产生的子问题往往是原问题的较小模式，这时反复使用分治手段，不断将问题规模缩小直至可以容易得到解。使用分治法的关键在于：原问题应该如何分割成子问题？子问题的规模如何确定？子问题是否容易求解？这些问题可能需要根据具体问题来进行回答，但是一般来说，用分治法设计算法时应该保证子问题规模大致相等。从这种设计模式可以看出，使用分治法设计的算法一般是递归算法，所以我们说即便大部分递归程序可以等价替换为非递归程序，但是递归与分治常常同时出现。

## 4.1二分查找

二分查找是十分常见的查找算法之一，并且是运用分治策略的经典例子。算法首先需要一个有序的数组，将中间元素和查找元素对比，如果大于查找元素，那么下一次查找将会在数组的左半部分查找，否则在右半部分查找。二分查找十分常见，其变种以及思想出现在各种算法设计结构中。

```c++
// 递归
int search(int* br, int left, int right, int val) 
{
    int pos = -1;
    if (left <= right) 
    {
        int mid = (right - left) / 2 + left;
        if (br[mid] > val)
            pos = search(br, left, mid - 1, val);
        else if (br[mid] < val)
            pos = search(br, mid + 1, right, val);
        else pos = mid;
    }
    return pos;
}
int binarySearch(int* br, int n, int val) 
{
	if (br == nullptr) return -1;
	return search(br, 0, n - 1, val);
}
// 非递归
int binarySearch(int* br, int n, int val) {
	if (br == nullptr) return -1;
	int pos = -1;
	int left = 0, right = n - 1;
	while (left <= right) {
		int mid = (right - left) / 2 + left;
		if (val < br[mid]) {
			right = mid - 1;
		}
		else if (val > br[mid]) {
			left = mid + 1;
		}
		else {
			pos = mid;
			break;
		}
	}
	return pos;
}
```

## 4.2快速排序

下面首先介绍快速排序 -- 一种使用分治策略的排序算法，对于足够无序的数列达到效率的最大化，相反对于越有序的数列效率越低。

```c++
// 快速排序的基本形式
int Partition(int* ar, int left, int right)
{
	int tmp = ar[left];
	while (left < right)
	{
		while (left < right && ar[right] >= tmp)--right;
		if (left < right) ar[left] = ar[right];
		while (left < right && ar[left] <= tmp)++left;
		if (left < right) ar[right] = ar[left];
	}
	ar[left] = tmp;
	return left;
}
void PassQuick(int* ar, int left, int right)
{
	if (left < right)
	{
		int pos = LeftPatition(ar, left, right);
		PassQuick(ar, left, pos - 1);
		PassQuick(ar, pos + 1, right);
	}
}
void Quick(int* ar, int n)
{
	if (ar == NULL || n < 2)return;
	PassQuick(ar, 0, n - 1);
}

```

快速排序使用递归形式定义，我们可以将其转换为非递归形式。使用栈或者队列实现，负责管理快速排序中划分时的下标。更方便的，用键值对的形式来存储划分时的下标，如下所示：

```c++
// 栈形式
void Quick_Stack(int* ar, int n)
{
	stack<int> st;
	st.push(0);
	st.push(n - 1);
	while (!st.empty())
	{
		int q = st.top();
		st.pop();
		int p = st.top();
		st.pop();
		int par = Partition(ar, p, q);
		if (p < par - 1)
		{
			st.push(p);
			st.push(par - 1);
		}
		if (par + 1 < q)
		{
			st.push(par + 1);
			st.push(q);
		}
	}
}
// 队列形式
void Quick_Queue(int* ar, int n)
{
	queue<int> qu;
	qu.push(0);
	qu.push(n - 1);
	while (!qu.empty())
	{
		int p = qu.front();
		qu.pop();
		int q = qu.front();
		qu.pop();
		int par = Partition(ar, p, q);
		if (p < par - 1)
		{
			qu.push(p);
			qu.push(par - 1);
		}
		if (par + 1 < q)
		{
			qu.push(par + 1);
			qu.push(q);
		}
	}
}
// 改进后的队列形式
void Quick_Queue_Pair_Update(int* ar, int n)
{
	typedef std::pair<int, int> PI;// 类型重定义
	queue<PI> qu;
	qu.push(PI(0, n - 1));
	while (!qu.empty())
	{
		PI p = qu.front();
		qu.pop();
		int pos = Partition(ar, p.first, p.second);
		if (p.first < pos - 1)
		{
			qu.push(PI(p.first, pos - 1));
		}
		if (pos + 1 < p.second)
		{
			qu.push(PI(pos + 1, p.second));
		}
	}
}
```

普通的快速排序仍然有很大的优化空间。决定快速排序效率的主要因素是划分之后元素在数列中的位置，越接近等分效率越高。所以我们主要针对划分算法，尽量找到一个合适的元素作为划分的依据，让其更容易等分整个区域：

```c++
int Partition(int* ar, int left, int right)
{
    // 普通划分
	int tmp = ar[left];
	while (left < right)
	{
		while (left < right && ar[right] >= tmp)--right;
		if (left < right) ar[left] = ar[right];
		while (left < right && ar[left] <= tmp)++left;
		if (left < right) ar[right] = ar[left];
	}
	ar[left] = tmp;
	return left;
}
int RandPartition(int* ar, int left, int right)
{
	// 随机算法
	srand(time(NULL));
	int pos = rand() % (right - left + 1) + left;
	std::swap(ar[left], ar[pos]);
	return Partition(ar, left, right);
}
int MidPartition(int* ar, int left, int right)
{
	// 三路取中法
	int mid = (right - left) / 2 + left;
	struct IndexNode
	{
		int key;
		int index;
		operator int() const { return key; }// 重载强转运算符
	};
	struct IndexNode kL = { ar[left],left };
	struct IndexNode kM = { ar[mid],mid };
	struct IndexNode kR = { ar[right],right };

	std::priority_queue<IndexNode> hp;
	hp.push(kL);hp.push(kM);hp.push(kR);
	hp.pop();
	struct IndexNode pos = hp.top();
	std::swap(ar[kL.index], ar[pos.index]);
	return Partition(ar, left, right);
}
```

目前的所有划分函数均是从数列两端开始划分，对于单链表一类的结构并不能做到双向划分，所以采用单项划分形式：

```c++
int LeftPatition(int* ar, int left, int right)
{
	// 单项划分
	int i = left;
	int j = left - 1;
	int tmp = ar[i];
	while (i <= right)
	{
		if (ar[i] <= tmp)
		{
			j = j + 1;
			std::swap(ar[j], ar[i]);
		}
		++i;
	}
	std::swap(ar[left], ar[j]);
	return j;
}
typedef int ElemType;
typedef struct ListNode
{
    // 简单单链表结构
	ElemType data;
	struct ListNode* next;
}ListNode, * LinkList;

ListNode* LeftPatition_List(ListNode* head, ListNode* end)
{
	// 链表单项划分
	ListNode* ip = head->next;
	ListNode* jp = head;
	int tmp = ip->data;
	while (ip != end)
	{
		if (ip->data <= tmp)
		{
			jp = jp->next;
			std::swap(jp->data, ip->data);
		}
		ip = ip->next;
	}
	std::swap(head->next->data, jp->data);
	return jp;
}
```

## 4.3归并排序

采用分治策略的排序算法，将待排序序列划分为两个大小大致相同的两个子集合，分别对这两个子集合进行排序，最终将有序的两个子集合合并成要求的排好需的集合。算法需要额外开辟一个原数列相同长度的缓冲区，用于存放中间结果。

```c++
// 归并排序，递归
void Copy(int* src, int* dest, int left, int right)
{
	while (left <= right)
	{
		dest[left] = src[left];
		left++;
	}
}
void Merge(int* src, int* dest, int left, int m, int right)
{
	int i = left, j = m + 1;
	int k = left;
	while (i <= m && j <= right)
	{
		dest[k++] = src[i] <= src[j] ? src[i++] : src[j++];
	}
	while (i <= m)
	{
		dest[k++] = src[i++];
	}
	while (j <= right)
	{
		dest[k++] = src[j++];
	}
}
void MergePass(int* src, int* dest, int left, int right)
{
	if (left < right)
	{
		int mid = (left + right) / 2;
		MergePass(src, dest, left, mid);
		MergePass(src, dest, mid + 1, right);

		Merge(src, dest, left, mid, right);
		Copy(dest, src, left, right);
	}
}
void MergeSort(int* ar, int n)
{
	if (ar == nullptr || n < 2)return;
	int* tmp = new int[n];
	MergePass(ar, tmp, 0, n - 1);
}
```

非递归归并策略与递归版本相同，主要需要考虑的是划分下标的问题。

```c++
// 非递归归并
void Merge(int* src, int* dest, int left, int m, int right)
{
	int i = left, j = m + 1;
	int k = left;
	while (i <= m && j <= right)
	{
		dest[k++] = src[i] <= src[j] ? src[i++] : src[j++];
	}
	while (i <= m)
	{
		dest[k++] = src[i++];
	}
	while (j <= right)
	{
		dest[k++] = src[j++];
	}
}
void MergePass(int* src, int* dest, int n, int s)
{
	int i = 0;
	for (i = 0;i + 2 * s - 1 <= n - 1;i = i + 2 * s)
	{
		Merge(src, dest, i, i + s - 1, i + 2 * s - 1);
	}
	if (n - 1 > i + s - 1)
	{
		Merge(src, dest, i, i + s - 1, n - 1);
	}
	else
	{
		for (int j = i;j < n;++j)
		{
			dest[j] = src[j];
		}
	}
}
void MergeSort(int* ar, int n)
{
	if (ar == nullptr || n < 2)return;
	int* tmp = new int[n];
	int s = 1;
	while (s < n)
	{
		MergePass(ar, tmp, n, s);
		s += s;
		MergePass(tmp, ar, n, s);
		s += s;
	}
	delete[]tmp;
}
```

## 4.4查找第k小

查找数组中第 k 小的元素并返回其值。一种思路是将数据进行排序，然后对已排序的数组查找第 k 小，但是缺点是时间复杂度高，还要先进行排序。另一种思路是进行二分，每次划分后会确定一个元素在数列中的位置，下标即可反映出它是第几小。然后通过下标与 k 值进行比较判断进行左划分还是右划分，递归这一过程找到第 k 小。

```c++
// 寻找第k小
int FindK(int* ar, int left, int right, int k)
{
	if (left == right && k == 1)return ar[left];
	int pos = Partition(ar, left, right);// 划分函数
	int j = pos - left + 1;
	if (k <= j)return FindK(ar, left, pos, k);
	else return FindK(ar, pos + 1, right, k - j);
}
int FindK_min(int* ar, int n, int k)
{
	if (ar == nullptr || n < 0 || k > n)return -1;
	return FindK(ar, 0, n - 1, k);
}
```

## 4.5最接近点对

查找数列中最接近点对，并且仅针对于一维情况下的最接近点对，对于二维、三维不适用。针对于该算法，可以套用查找第 k 小的算法框架，因为其给出了一种确定数组中任意位置元素的方法。首先通过查找第 k 小的算法找到数列的中间值，这样做的原因是将数列划分为等长的两个部分，然后递归这一过程，直到子数列仅有一个元素，这时返回无穷大，因为一个元素无法给出最小差值。计算左半部分的最小差值，右半部分的最小差值，以及右半部分最小值和左半部分最大值之差进行比较，找到最小值，逐层回归得到整个数列的最小差值。

```c++
// 一维最小差值
int MaxS1(int* ar, int left, int right)
{
	return ar[right];
}
int MinS2(int* ar, int left, int right)
{
	int mins = ar[left];
	for (int i = left + 1;i <= right;++i)
	{
		if (mins > ar[i])
		{
			mins = ar[i];
		}
	}
	return mins;
}
int Min(int a, int b, int c) {
	int min = a < b ? a : b;
	min = min < c ? min : c;
	return min;
}
int Cpair(int* ar, int left, int right)
{
	if ((right - left <= 0))return INT_MAX;
	int mid = (right - left + 1) / 2;
	FindK(ar, left, right, mid);
	int pos = left + mid - 1;
	int d1 = Cpair(ar, left, pos);
	int d2 = Cpair(ar, pos + 1, right);

	int maxs = MaxS1(ar, left, pos);
	int mins = MinS2(ar, pos + 1, right);
	return Min(d1, d2, mins - maxs);
}
int Cpair_Ar(int* ar, int n)
{
	if (ar == nullptr || n < 2)return INT_MAX;
	else return Cpair(ar, 0, n - 1);
}
```

## 4.6全排列

给出数列，打印出这个数列的全排列。传入数列、数列的开始和结束下标。比如输入数列为1，2，3，全排列应该为：

123，132，213，231，312，321。

```c++
// 查找全排列，排列树
void Perm(int* ar, int i, int m)
{
    // ar[] = 1,2,3
    // i = 0, m = 2
	if (i == m)
	{
		for (int j = 0; j <= m; j++)
		{
			cout << ar[j] << " ";
		}
		cout << endl;
	}
	else
	{
		for (int j = i; j <= m; j++)
		{
			std::swap(ar[i], ar[j]);
			Perm(ar, i + 1, m);
			std::swap(ar[i], ar[j]);
		}
	}
}
```

## 4.7查找子集

给出数列，输出该数列的所有子数列（包含空集）。给出数列、辅助数组、开始下标和元素个数。函数递归形成一个树形结构，每一个从根结点到叶子结点可以看成数列的一个子集序列，通过辅助数组记录 0 或者 1，由此确定子集序列的输出结果。

```c++
// 查找子集，子集树
void Print(int* ar, int* br, int i, int n)
{
    // ar[] = 1,2,3
    // br[] = 0,0,0
    // i = 0, n = 3
	if (i >= n)
	{
		for (int j = 0; j < n; j++)
		{
			if (br[j] == 1)
			{
				cout << ar[j] << " ";
			}
		}
		cout << endl;
	}
	else
	{
		br[i] = 1;
		Print(ar, br, i + 1, n);
		br[i] = 0;
		Print(ar, br, i + 1, n);
	}
}
```

# 5.树形结构

这部分主要涉及到二叉树、二叉排序树（BST）、平衡二叉树（AVL）、红黑树、T树、B-树、B+树、B*树。

## 5.1预备知识

$$
\begin{align*}
 & 1.在二叉树的第i(i\geq1)层最多有2^{i-1}个结点。\\
 & 2.深度为k(k\geq0)的二叉树最多有k个结点，最少有2^i-1个结点。\\
 & 3.对于任何一颗非空二叉树，叶子结点个数为n_0，度为2的非叶子结点个数为n_2，则n_0=n_2+1。\\
 & 4.具有n个结点的完全二叉树的最小深度为\log_2{n+1}(向上取整)。\\
 & 5.二叉树自顶向下，从左至右从1开始编号，对于编号为i的结点，其左孩子编号为2*i，右孩子为2*i+1(存在且不越界)。
\end{align*}
$$

## 5.2普通二叉树

### 5.2.1构建二叉树

第一种方案是使用顺序存储形式存放二叉树，简单的情况下只需要一个数组即可。数组的下标用于表示二叉树的逻辑关系，即通过此方式表征一个二叉树。这种方法的优点是简单快捷，缺点也是显而易见的：当二叉树复杂或者比较特殊时，空间耗损将会增大。第二种方案是采用链式结构存储二叉树，在这种情况下，需要数据域、左孩子域、右孩子域用以形成二叉树的每一个结点。第二种方案较为常用，一般情况下我们都会使用这种方案。

采用链式方式设计时，一般情况是读取一个序列，它应该是一个先序序列，并且需要显式指明空结点。函数首先构建根结点，然后递归地构建根结点的左子树和右子树。另外一种方案十分巧妙：给出二叉树的前序、中序、后序序列，我们根据前、中序序列或者中、后序序列决定二叉树的结构。这是由于二叉树的性质决定：二叉树的前序序列的首元素一定是根结点，二叉树的后序序列的最后一个元素一定是根结点。配合中序序列，我们可以递归地构建整个二叉树。

```c++
typedef char elemtype;
typedef struct BtNode
{
	struct BtNode* leftchild;
	struct BtNode* rightchild;
	elemtype data;
}BtNode, * BinaryTree;

BtNode* buynode()
{
	BtNode* s = (BtNode*)malloc(sizeof(BtNode));
	if (s == NULL)exit(1);
	memset(s, 0, sizeof(BtNode));
	return s;
}

BtNode* CreateBinaryTree()
{
	BtNode * root = NULL;
	elemtype data;
	cin >> data;
	if (data != '#')
	{
		root = buynode();
		root->data = data;
		root->leftchild = CreateBinaryTree();
		root->rightchild = CreateBinaryTree();
	}
	return root;
}

int FindIs(const char* is, int n, int num)
{
	int pos = -1;
	for (int i = 0; i < n; i++)
	{
		if (is[i] == num)
		{
			pos = i;
			break;
		}
	}
	return pos;
}

BtNode* CreateBTree_PI(const char* ps, const char* is, int n)
{
	// 前、中序序列构建二叉树
	BtNode* s = NULL;
	if (n >= 1)
	{
		s = buynode();
		s->data = ps[0];
		int pos = FindIs(is, n, ps[0]);
		if (pos == -1)exit(1);
		s->leftchild = CreateBTree_PI(ps + 1, is, pos);
		s->rightchild = CreateBTree_PI(ps + 1 + pos, is + 1 + pos, n - pos - 1);
	}
	return s;
}

BtNode* CreateBTree_IL(const char* is, const char* ls, int n)
{
	// 中、后序序列构建二叉树
	BtNode* s = NULL;
	if (n >= 1)
	{
		s = buynode();
		s->data = ls[n - 1];
		int pos = FindIs(is, n, ls[n - 1]);
		if (pos == -1)exit(1);
		s->leftchild = CreateBTree_IL(is, ls, pos);
		s->rightchild = CreateBTree_IL(is + 1 + pos, ls + pos, n - pos - 1);
	}
	return s;
}

//			  A
//			/   \
//		   B     G
//		  / \     \
//		 C	 D     H
//          / \
//		   E   F
/*
pre		A B C D E F G H
in		C B E D F A G H
past	C E F D B H G A
*/

int main()
{
	const char* str = "ABC##DE##F##G#H##";
	char ps[] = { "ABCDEFGH" };
	char is[] = { "CBEDFAGH" };
	char ls[] = { "CEFDBHGA" };

	int n = strlen(ps);
	BinaryTree root = CreateBinaryTree();
	BinaryTree root = CreateBTree_PI(ps, is, n);
	BinaryTree root = CreateBTree_IL(is, ls, n);
	
	return 0;
}
```

### 5.2.2二叉树遍历

二叉树的前序、中序、后序遍历。

```c++
void PreOrder(BtNode* root)
{
	if (root != NULL)
	{
		cout << root->data << " ";
		PreOrder(root->leftchild);
		PreOrder(root->rightchild);
	}
}

void InOrder(BtNode* root)
{
	if (root != NULL)
	{
		InOrder(root->leftchild);
		cout << root->data << " ";
		InOrder(root->rightchild);
	}
}

void PastOrder(BtNode* root)
{
	if (root != NULL)
	{
		PastOrder(root->leftchild);
		PastOrder(root->rightchild);
		cout << root->data << " ";
	}
}
```

将中序遍历和后序遍历转换成非递归版本：

```c++
void NiceInOrder(BtNode* root)
{
    // 非递归中序
	if (root == NULL)return;
	stack<BtNode*> st;
	while (root != NULL || !st.empty())
	{
		while (root != NULL)
		{
			st.push(root);
			root = root->leftchild;
		}
		root = st.top();
		st.pop();
		cout << root->data << " ";
		root = root->rightchild;
	}
	cout << endl;
}

void NicePastOrder(BtNode* root)
{
    // 非递归后序
	if (root == NULL)return;
	stack<BtNode*> st;
	BtNode* tag = NULL;
	while (root != NULL || !st.empty())
	{
		while (root != NULL)
		{
			st.push(root);
			root = root->leftchild;
		}
		root = st.top();
		st.pop();
		if (root->rightchild == NULL || root->rightchild == tag)
		{
			cout << root->data << " ";
			tag = root;
			root = NULL;
		}
		else
		{
			st.push(root);
			root = root->rightchild;
		}
	}
	cout << endl;
}
```

除了上述方式外，借助一个计数的结构体来决定什么时候输出元素可以完成二叉树的遍历。每次遍历到一个结点，都会增加该结点的访问次数。对于中序遍历来说，第二次访问到任意结点，就应该从出栈并打印，否则不出栈；对于后序遍历来说，第三次访问到任意结点才应该出栈并打印，否则不出栈；而对于前序遍历，由于第一次访问到任意结点就应该出栈并打印，所以不需要设计计数的结构体。

```c++
class StkNode// 统计结点访问次数的结构体
{
public:
	BtNode* ptr;// 指向二叉树结点的指针
	int count;// 访问次数，默认为0
public:
	StkNode(BtNode* p) :ptr(p), count(0) {}
};
void StkNicePastOrder(BtNode* root)
{
    // 非递归后序
	if (root == NULL)return;
	stack<StkNode> st;
	st.push(StkNode(root));
	while (!st.empty())
	{
		StkNode node = st.top();
		st.pop();
		if (++node.count == 3)
		{
			cout << node.ptr->data << " ";
		}
		else
		{
			st.push(node);
			if (node.count == 1 && node.ptr->leftchild != NULL)
			{
				st.push(StkNode(node.ptr->leftchild));
			}
			else if (node.count == 2 && node.ptr->rightchild != NULL)
			{
				st.push(StkNode(node.ptr->rightchild));
			}
		}
	}
	cout << endl;
}
void StkNiceInOrder(BtNode* root)
{
    // 非递归中序
	if (root == NULL)return;
	stack<StkNode> st;
	st.push(StkNode(root));
	while (!st.empty())
	{
		StkNode node = st.top();
		st.pop();
		if (++node.count == 2)
		{
			cout << node.ptr->data << " ";
			if (node.ptr->rightchild != NULL)
			{
				st.push(StkNode(node.ptr->rightchild));
			}
		}
		else
		{
			st.push(node);
			if (node.count == 1 && node.ptr->leftchild != NULL)
			{
				st.push(StkNode(node.ptr->leftchild));
			}
		}
	}
	cout << endl;
}

void NicePreOrder(BtNode* root)
{
    // 非递归前序
	if (root == NULL)return;
	stack<BtNode*> st;
	st.push(root);
	while (!st.empty())
	{
		BtNode* ptr = st.top();
		st.pop();
		cout << ptr->data << " ";
		if (ptr->rightchild != NULL)
		{
			st.push(ptr->rightchild);
		}
		if (ptr->leftchild != NULL)
		{
			st.push(ptr->leftchild);
		}
	}
	cout << endl;
}
```

二叉树的层序遍历，Z字形遍历。

```c++
void LevelOrder(BtNode* root)
{
	// 层序遍历
	if (root == NULL)return;
	queue<BtNode*>qu;
	qu.push(root);
	while (!qu.empty())
	{
		root = qu.front();
		qu.pop();
		if (root->leftchild != NULL)
		{
			qu.push(root->leftchild);
		}
		if (root->rightchild != NULL)
		{
			qu.push(root->rightchild);
		}
		cout << root->data << " ";
	}
	cout << endl;
}
void ZLevelOrder(BtNode* root)
{
	// Z字形层序遍历
	if (root == NULL)return;
	stack<BtNode*>sta;
	stack<BtNode*>stb;
	sta.push(root);
	while (!sta.empty() || !stb.empty())
	{
		while (!sta.empty())
		{
			root = sta.top();
			sta.pop();
			cout << root->data << " ";
			if (root->leftchild != NULL)
			{
				stb.push(root->leftchild);
			}
			if (root->rightchild != NULL)
			{
				stb.push(root->rightchild);
			}
		}
		while (!stb.empty())
		{
			root = stb.top();
			stb.pop();
			cout << root->data << " ";
			if (root->rightchild != NULL)
			{
				sta.push(root->rightchild);
			}
			if (root->leftchild != NULL)
			{
				sta.push(root->leftchild);
			}
		}
	}
	cout << endl;
}
```

### 5.2.3二叉树的其他操作

统计二叉树的结点个数，以及二叉树的深度。

```c++
int Count(BtNode* root)
{
	// 统计结点个数
	if (root == NULL) return 0;
	return Count(root->leftchild) + Count(root->rightchild) + 1;
}

int Depth(BtNode* root)
{
	// 计算二叉树深度
	if (root == NULL)return 0;
	return std::max(Depth(root->leftchild), Depth(root->rightchild)) + 1;
}
```

判断二叉树是否是满二叉树，是否是完全二叉树。

```c++
bool Is_FullBinaryTree(BtNode* root)
{
	// 是否是满二叉树
	bool tag = true;
	if (root == NULL)return tag;
	queue<BtNode*>qua;
	queue<BtNode*>qub;
	int s = 1;
	qua.push(root);
	while (!qua.empty() || !qub.empty())
	{
		if (s != qua.size() && !qua.empty())
		{
			tag = false;
			break;
		}
		while (!qua.empty())
		{
			root = qua.front();
			qua.pop();
			if (root->leftchild != NULL)qub.push(root->leftchild);
			if (root->rightchild != NULL)qub.push(root->rightchild);
		}
		s += s;
		if (s != qub.size() && !qub.empty())
		{
			tag = false;
			break;
		}
		while (!qub.empty())
		{
			root = qub.front();
			qub.pop();
			if (root->leftchild != NULL)qua.push(root->leftchild);
			if (root->rightchild != NULL)qua.push(root->rightchild);
		}
		s += s;
	}
	return tag;
}

bool Is_ComBinaryTree(BtNode* root)
{
	// 是否是完全二叉树
	bool tag = true;
	if (root == NULL)return tag;
	queue<BtNode*> qu;
	qu.push(root);
	while (!qu.empty())
	{
		root = qu.front();
		if (root == NULL)
		{
			break;
		}
		qu.pop();
		qu.push(root->leftchild);
		qu.push(root->rightchild);
	}
	while (!qu.empty())
	{
		root = qu.front();
		if (root != NULL)
		{
			tag = false;
			break;
		}
		qu.pop();
	}
	return tag;
}
```

普通二叉树查询元素，成功返回指向结点结构体指针，失败返回空指针。

```c++
BtNode* FindValue(BtNode* root, char val)
{
	// 普通二叉树查找val值
	if (root == NULL || root->data == val)
	{
		return root;
	}
	else
	{
		BtNode* ptr = FindValue(root->leftchild, val);
		if (ptr == NULL)
		{
			ptr = FindValue(root->rightchild, val);
		}
		return ptr;
	}
}
```

普通二叉树查询父结点，成功返回父结点指针，失败返回空指针。

```c++
BtNode* FindPa(BtNode* root, BtNode* child)
{
	if (root == NULL || root->leftchild == child || root->rightchild == child)
	{
		return root;
	}
	else
	{
		BtNode* ptr = FindPa(root->leftchild, child);
		if (NULL == ptr)
		{
			ptr = FindPa(root->rightchild, child);
		}
		return ptr;
	}
}
BtNode* FindParent(BtNode* root, BtNode* child)
{
	// 普通二叉树查找父结点
	if (root == NULL || child == NULL || root == child) return NULL;
	else return FindPa(root, child);
}
```

## 5.3二叉排序树

二叉排序树也叫二叉搜索树，从结构上来讲与普通二叉树差别不大，仅多出了指向父结点的指针。逻辑层面二叉搜索树有以下特点：每一个结点的左子树均小于该结点，每一个结点的右子树均大于该结点。这个特性体现在执行中序遍历的时候，二叉搜索树呈现递增序列。

构建空的排序二叉树时，预先给出空指针作为根结点，然后在函数内进行建根操作是程序的初始化逻辑。二叉排序树的第一个难点在于如何给出任意结点的直接后继（前驱）结点？这个问题的切入点是二叉排序树的最左（最右）结点是所有元素中值最小（最大）的结点。如果可以得出任意结点的后继或者前驱，那么可以实现更为简洁的二叉排序树的中序遍历代码；第二个问题是二叉排序树的删除如何进行？这个问题应该分三种情况讨论：删除结点是叶子结点，删除结点是单分支结点，删除结点是双分支结点，讨论上述三种情况的处理，正是程序中所处理的情况。

```c++
typedef int keytype;
typedef struct BstNode
{
	struct BstNode* leftchild;
	struct BstNode* rightchild;
	struct BstNode* parent;
	keytype data;
}BstNode, * BinarySearchTree;

BstNode* buynode()
{
	BstNode* s = (BstNode*)malloc(sizeof(BstNode));
	if (s == NULL)exit(1);
	memset(s, 0, sizeof(BstNode));
	return s;
}
bool Insert(BstNode*& root, keytype kx)
{
    // 插入
	if (root == NULL)
	{
		root = buynode();
		root->data = kx;
	}
	BstNode* parent = NULL;
	BstNode* p = root;
	while (p != NULL && p->data != kx)
	{
		parent = p;
		p = kx < p->data ? p->leftchild : p->rightchild;
	}
	if (p != NULL && p->data == kx)
		return false;
	p = buynode();
	p->data = kx;
	p->parent = parent;
	if (kx < parent->data) { parent->leftchild = p; }
	else { parent->rightchild = p; }
	return true;
}

BstNode* First(BstNode* root)
{
	// 最小元素
	while (root != NULL && root->leftchild != NULL)
	{
		root = root->leftchild;
	}
	return root;
}

BstNode* Next(BstNode* root)
{
	// 后继
	if (root == NULL) return root;
	if (root->rightchild != NULL)
	{
		return First(root->rightchild);
	}
	else
	{
		BstNode* pa = root->parent;
		while (pa != NULL && pa->leftchild != root)
		{
			root = pa;
			pa = root->parent;
		}
		return pa;
	}
}

BstNode* Last(BstNode* root)
{
	// 最大元素
	while (root != NULL && root->rightchild != NULL)
	{
		root = root->rightchild;
	}
	return root;
}

BstNode* Prev(BstNode* root)
{
	// 前驱
	if (root == NULL)return NULL;
	if (root->leftchild != NULL)
	{
		return Last(root->leftchild);
	}
	else
	{
		BstNode* pa = root->parent;
		while (pa != NULL && pa->rightchild != root)
		{
			root = pa;
			pa = root->parent;
		}
		return pa;
	}
}

bool Remove(BstNode*& root, keytype kx)
{
    // 删除
	if (root == NULL)return false;
	BstNode* p = root;
	while (p != NULL && p->data != kx)
	{
		p = kx < p->data ? p->leftchild : p->rightchild;
	}
	if (p == NULL)return false;
	if (p->leftchild != NULL && p->rightchild != NULL)
	{
        // 双分支
		BstNode* last = First(p->rightchild);
		p->data = last->data;
		p = last;
	}
	BstNode* pa = p->parent;
	BstNode* child = p->leftchild != NULL ? p->leftchild : p->rightchild;// 单分支
	if (child != NULL)child->parent = pa;
	if (pa == NULL)
	{
		root = child;
	}
	else
	{
        // 叶子
		if (pa->leftchild == p)
		{
			pa->leftchild = child;
		}
		else
		{
			pa->rightchild = child;
		}
	}
	free(p);
	return true;
}

void NiceInOrder(BstNode* root)
{
	// 正序
	for (BstNode* p = First(root); p != NULL; p = Next(p))
	{
		cout << p->data << " ";
	}
	cout << endl;
}

void RevNiceInOrder(BstNode* root)
{
	// 逆序
	for (BstNode* p = Last(root); p != NULL; p = Prev(p))
	{
		cout << p->data << " ";
	}
	cout << endl;
}
```

## 5.4平衡二叉树

也叫AVL树，在二叉排序树的基础上引入了平衡因子的概念。由于普通的二叉排序树并没有对树的结构提出特别的限制，所以当出现一些特殊情况时将会降低二叉排序树的查询效率。AVL树的特点是严格限制每一个结点的左子树和右子树的高度差不能大于一，也就是说随着结点的不断插入，有可能破坏当前二叉树的“平衡”，所以需要对平衡二叉树进行动态的调整，使其再次“平衡”。

平衡二叉树是由二叉排序树发展而来，所以结构与二叉排序树类似，仅仅多了一个表示当前结点状态的平衡因子：如果该结点的左子树与右子树高度相同，那么平衡因子为零；如果左子树比右子树高 1，那么平衡因子为 -1；如果右子树比左子树高 1，那么平衡因子为 -1。一旦平衡因子的绝对值大于等于 2，说明当前位置失衡，需要进行调整恢复平衡。平衡二叉树的难点在于：如何判断结点不平衡？如何调整二叉树让其平衡？首先从基本问题出发，调整树的结构可以使用旋转，结合不同的情况来更新重新恢复平衡的结点的平衡因子来判断是否需要再次恢复平衡。

```c++
typedef int keytype;
typedef struct AVLNode
{
	struct AVLNode* leftchild;
	struct AVLNode* rightchild;
	struct AVLNode* parent;
	keytype data;
	int balance;// 平衡因子
}AVLNode, * AVLTree;

AVLNode* Buynode(keytype kx)
{
	AVLNode* s = (AVLNode*)malloc(sizeof(AVLNode));
	if (s == NULL)exit(1);
	memset(s, 0, sizeof(AVLNode));
	s->data = kx;
	s->balance = 0;
	return s;
}

AVLNode* MakeRoot(keytype kx)
{
	AVLNode* root = Buynode(kx);
	return root;
}
void RotateLeft(AVLTree& tree, AVLNode* ptr)
{
	AVLNode* newroot = ptr->rightchild;
	newroot->parent = ptr->parent;
	ptr->rightchild = newroot->leftchild;
	if (newroot->leftchild != NULL)
	{
		newroot->leftchild->parent = ptr;
	}
	newroot->leftchild = ptr;
	if (ptr == tree)
	{
		tree = newroot;
	}
	else
	{
		if (ptr->parent->leftchild == ptr)
		{
			ptr->parent->leftchild = newroot;
		}
		else
		{
			ptr->parent->rightchild = newroot;
		}
	}
	ptr->parent = newroot;
}

void RotateRight(AVLTree& tree, AVLNode* ptr)
{
	AVLNode* newroot = ptr->leftchild;
	newroot->parent = ptr->parent;
	ptr->leftchild = newroot->rightchild;
	if (newroot->rightchild != NULL)
	{
		newroot->rightchild->parent = ptr;
	}
	newroot->rightchild = ptr;
	if (ptr == tree)
	{
		tree = newroot;
	}
	else
	{
		if (ptr->parent->leftchild == ptr)
		{
			ptr->parent->leftchild = newroot;
		}
		else
		{
			ptr->parent->rightchild = newroot;
		}
	}
	ptr->parent = newroot;
}

void RightBalance(AVLTree& tree, AVLNode* ptr)
{
	AVLNode* rightsub = ptr->rightchild, * leftsub = NULL;
	switch (rightsub->balance)
	{
	case 0:
		cout << "right balance" << endl;break;
	case 1:
		ptr->balance = 0;
		rightsub->balance = 0;
		RotateLeft(tree, ptr);
		break;
	case -1:
		leftsub = rightsub->leftchild;
		switch (leftsub->balance)
		{
		case -1:
			ptr->balance = 0;
			rightsub->balance = 1;
			break;
		case 1:
			ptr->balance = -1;
			rightsub->balance = 0;
			break;
		case 0:	
			ptr->balance = 0;
			rightsub->balance = 0;
	
			break;
		}
		leftsub->balance = 0;
		RotateRight(tree, rightsub);
		RotateLeft(tree, ptr);
		break;
	}
}

void LeftBalance(AVLTree& tree, AVLNode* ptr)
{
	AVLNode* leftsub = ptr->leftchild, * rightsub = NULL;
	switch (leftsub->balance)
	{
	case 0:
		cout << "left banlance" << endl;break;
	case -1:
		ptr->balance = 0;
		leftsub->balance = 0;
		RotateRight(tree, ptr);
		break;
	case 1:
		rightsub = leftsub->rightchild;
		switch (rightsub->balance)
		{
		case -1:
			leftsub->balance = 0;
			ptr->balance = 1;
			break;
		case 1:
			leftsub->balance = -1;
			ptr->balance = 0;
			break;
		case 0:
			leftsub->balance = 0;
			ptr->balance = 0;
			break;
		}
		rightsub->balance = 0;
		RotateLeft(tree, leftsub);
		RotateRight(tree, ptr);
		break;
	}
}

void PassBalance(AVLTree& tree, AVLNode* ptr)
{
	AVLNode* pa = ptr->parent;
	bool tall = true;
	for (; pa != NULL && tall; )
	{
		if (pa->leftchild == ptr)
		{
			switch (pa->balance)
			{
			case 0: 
				pa->balance = -1;
				break;
			case 1: 
				pa->balance = 0;
				tall = false;
				break;
			case -1: 
				LeftBalance(tree, pa);
				tall = false;
				break;
			}
		}
		else
		{
			switch (pa->balance)
			{
			case 0: 
				pa->balance = 1;
				break;
			case -1: 
				pa->balance = 0;
				tall = false;
				break;
			case 1: 
				RightBalance(tree, pa);
				tall = false;
				break;
			}
		}
		ptr = pa;
		pa = ptr->parent;
	}
}

bool Insert(AVLNode*& tree, keytype kx)
{
	if (tree == NULL)
	{
		tree = MakeRoot(kx);
		return true;
	}
	AVLNode* parent = NULL;
	AVLNode* p = tree;
	while (p != NULL && p->data != kx)
	{
		parent = p;
		p = kx < p->data ? p->leftchild : p->rightchild;
	}
	if (p != NULL && p->data == kx)
		return false;
	p = Buynode(kx);
	p->parent = parent;
	if (kx < parent->data) { parent->leftchild = p; }
	else { parent->rightchild = p; }
	PassBalance(tree, p);
	return true;
}
```

## 5.5红黑树

AVL树可以看成是一种严格平衡的二叉树，因为它不允许其左右子树的高度差大于 1，但是红黑树没有强制规定此要求，虽然也属于一种平衡二叉树，但是红黑树有一套自己的规则，如下所示：

> 1.每个结点是红色或者黑色。
> 2.根结点是黑色。
> 3.每个叶结点是黑色。
> 4.每个红色结点的两个子结点都是黑色。（从每个叶子到根的所有路径上不能有两个连续的红色结点）
> 5.从任一结点到其每个叶子的所有路径都包含相同数目的黑色结点。

相对于AVL树，红黑树是一种“不严格”平衡的二叉树，更准确的说红黑树可以保证左右子树高度差不超过最低子树高度的二倍。AVL树根据平衡因子判断树是否失衡，而红黑树通过结点的颜色来判断树是否失衡。一般来说，红黑树的结构由一个头结点和一个哨兵结点维护，由于具有二叉排序树的性质，其头结点的三个指针分别指向红黑树的最小结点，根结点以及最大结点，哨兵结点保持黑色并且所有结点在构建时都应该以哨兵结点作为子结点初始化。

```c++
typedef int KeyType;
typedef enum { RED = 0, BLACK = 1 } ColorType;
typedef struct rb_node
{
	rb_node* leftchild;
	rb_node* rightchild;
	rb_node* parent;
	ColorType color;
	KeyType key;
}rb_node, * RBTree;
rb_node* MakeRoot(KeyType kx);
static rb_node* Nil = MakeRoot(0);// 哨兵结点

rb_node* Buynode()
{
	rb_node* s = (rb_node*)malloc(sizeof(rb_node));
	if (nullptr == s)exit(1);
	memset(s, 0, sizeof(rb_node));
	s->leftchild = Nil;
	s->rightchild = Nil;
	s->color = RED;
	return s;
}

rb_node* MakeRoot(KeyType kx)
{
	rb_node* root = Buynode();
	root->color = BLACK;
	root->key = kx;
	return root;
}


void RotateLeft(rb_node*& tree, rb_node* ptr)
{
	rb_node* newroot = ptr->rightchild;
	newroot->parent = ptr->parent;
	ptr->rightchild = newroot->leftchild;
	if (newroot->leftchild != NULL)
	{
		newroot->leftchild->parent = ptr;
	}
	newroot->leftchild = ptr;
	if (ptr == tree)
	{
		tree = newroot;
	}
	else
	{
		if (ptr->parent->leftchild == ptr)
		{
			ptr->parent->leftchild = newroot;
		}
		else
		{
			ptr->parent->rightchild = newroot;
		}
	}
	ptr->parent = newroot;
}

void RotateRight(rb_node*& tree, rb_node* ptr)
{
	rb_node* newroot = ptr->leftchild;
	newroot->parent = ptr->parent;
	ptr->leftchild = newroot->rightchild;
	if (newroot->rightchild != NULL)
	{
		newroot->rightchild->parent = ptr;
	}
	newroot->rightchild = ptr;
	if (ptr == tree)
	{
		tree = newroot;
	}
	else
	{
		if (ptr->parent->leftchild == ptr)
		{
			ptr->parent->leftchild = newroot;
		}
		else
		{
			ptr->parent->rightchild = newroot;
		}
	}
	ptr->parent = newroot;
}

void PassRBTree(rb_node*& tree, rb_node* p)
{
	rb_node* _X = NULL;
	for (; p != tree && p->parent->color == RED;)
	{
		if (p->parent->parent->rightchild == p->parent)
		{
			_X = p->parent->parent->leftchild;
			if (_X->color == RED)
			{
				_X->color = BLACK;
				p->parent->color = BLACK;
				p->parent->parent->color = RED;
				p = p->parent->parent;
			}
			else
			{
				if (p->parent->leftchild == p)
				{
					p = p->parent;
					RotateRight(tree, p);
				}
				p->parent->color = BLACK;
				p->parent->parent->color = RED;
				RotateLeft(tree, p->parent->parent);
			}
		}
		else
		{
			_X = p->parent->parent->rightchild;
			if (_X->color == RED)
			{
				_X->color = BLACK;
				p->parent->color = BLACK;
				p->parent->parent->color = RED;
				p = p->parent->parent;
			}
			else
			{
				if (p->parent->rightchild == p)
				{
					p = p->parent;
					RotateLeft(tree, p);
				}
				p->parent->color = BLACK;
				p->parent->parent->color = RED;
				RotateRight(tree, p->parent->parent);
			}
		}
	}
	tree->color = BLACK;
}

bool Insert(rb_node*& tree, KeyType kx)
{
	if (tree == NULL)
	{
		tree = MakeRoot(kx);
		return true;
	}
	rb_node* parent = Nil;
	rb_node* p = tree;
	while (p != Nil && p->key != kx)
	{
		parent = p;
		p = kx < p->key ? p->leftchild : p->rightchild;
	}
	if (p != Nil) return false;
	p = Buynode();
	p->key = kx;
	p->parent = parent;
	if (kx < parent->key) { parent->leftchild = p; }
	else { parent->rightchild = p; }
	PassRBTree(tree, p);
	return true;
}
```

## 5.6 T树

T树也叫做检索树、Trie 树，这种结构维护了若干多重链表作为索引，并将叶子结点包装为关键字域和记录集指针。常见的动作是将英文单词组织进T树结构，查找时通过字典树定位至某个叶子结点，然后取得所需的记录集指针。Trie 树中有两种结点：一种是分支结点，主要包含一个多重链表，作为索引；一种是叶子结点，主要包含关键字和记录集指针。

![TrieTree](D:\0A_Myfile\markdown\TrieTree.png)

根据上图组织的字典树可以用来查找特定关键字所对应的记录集。尽管它和二叉查找树差别很大，但是 Trie 树仍然可以视为一种特殊的查找树。下面的代码将会维护一个类似上图的数据结构。需要说明的是，T树的根据关键字作为依据进行查找，并根据关键字找到对应的记录集指针。

```c++
struct TrieNode;
const int MaxKeySize = 25;// 关键码最大长度
const int LETLEN = 27;
typedef enum { BRCH = 0, ELEM = 1 } NodeType;
typedef struct
{
	char ch[MaxKeySize];
	int currentSize;
}KeyType;
typedef struct
{
	KeyType key;// 关键码
	void* recptr;// 记录集指针
}ElemType;// 元素类型
typedef struct
{
	TrieNode* link[LETLEN];
}BrchType;// 分支类型
struct TrieNode
{
	NodeType utype;
	union
	{
		ElemType item;
		BrchType brch;
	};
};
class TrieTree
{
private:
	TrieNode* root;
	static int Index(const KeyType& kx, int k)
	{
		int index = 0;
		if (k < kx.currentSize)
		{
			index = kx.ch[k] - 'a' + 1;
		}
		return index;
	}
	static TrieNode* Buynode()
	{
		TrieNode* s = (TrieNode*)malloc(sizeof(TrieNode));
		if (s == nullptr) exit(1);
		memset(s, 0, sizeof(TrieNode));
		return s;
	}
	static TrieNode* MakeElem(const ElemType& item)
	{
		TrieNode* s = Buynode();
		s->utype = ELEM;
		s->item = item;
		return s;
	}
	static TrieNode* MakeBrch(TrieNode* ptr, int k)
	{
		TrieNode* s = Buynode();
		s->utype = BRCH;
		int index = Index(ptr->item.key, k);
		s->brch.link[index] = ptr;
		return s;
	}
public:
	TrieTree() :root(nullptr) {}
	~TrieTree() {}
	TrieNode* Find(const KeyType& kx)// 根据关键码查询
	{
		TrieNode* p = root;
		int k = 0;
		while (p != nullptr && p->utype == BRCH)
		{
			int index = Index(kx, k);
			k += 1;
			p = p->brch.link[index];
		}
		if (p != nullptr && strcmp(kx.ch, p->item.key.ch) != 0)
		{
			p = nullptr;
		}
		return p;
	}
	void Insert_Item(TrieNode*& ptr, const ElemType& item, int k)
	{
		if (ptr == nullptr)
		{
			ptr = MakeElem(item);
		}
		else if (ptr->utype == BRCH)
		{
			int index = Index(item.key, k);
			Insert_Item(ptr->brch.link[index], item, k + 1);
		}
		else if (ptr->utype == ELEM)
		{
			ptr = MakeBrch(ptr, k);
			int index = Index(item.key, k);
			Insert_Item(ptr->brch.link[index], item, k + 1);
		}
	}
	bool Insert(const ElemType& item)// 根据元素类型插入
	{
		TrieNode* p = Find(item.key);
		if (p != nullptr)
		{
			return false;
		}
		int k = 0;
		Insert_Item(root, item, k);
		return true;
	}
};
int main()
{
	TrieTree tt;
	KeyType kx[] = { "data",4,"eye",3,"date",4,"dat",3,"egg",3 };
	int n = sizeof(kx) / sizeof(kx[0]);
	for (int i = 0; i < n; ++i)
	{
		ElemType item = { kx[i],nullptr };
		tt.Insert(item);
	}
	return 0;
}
```

## 5.7 B-树

B-树简称B树，是一种多路搜索树，虽然思路与二叉搜索树类似，但是在数据组织和架构上更为复杂，这也赋予B-树更强的搜索能力。B-树的结点类型有较为复杂的结构，当中同时包含数据和分支，在插入数据和查询时需要注意数据插入方式以及结点的分配问题。

```c++
#define M 5
#define MAXSIZE (M-1)
#define MINSIZE (M/2)
typedef char KeyType;
typedef struct {}Record;
typedef struct
{
	KeyType key;
	Record* recptr;
}ElemType;

typedef struct BNode
{
	int num;
	struct BNode* parent;
	ElemType data[M + 1];
	struct BNode* sub[M + 1];
}BNode;
typedef struct
{
	struct BNode* root;
	int cursize;
}BTree;
typedef struct
{
	struct BNode* ptr;
	int index;
	bool tag;
}Result;
BNode* Buynode()
{
	BNode* s = (BNode*)malloc(sizeof(BNode));
	if (nullptr == s)exit(1);
	memset(s, 0, sizeof(BNode));
	return s;
}
void Init_BTree(BTree& tree)
{
	tree.root = nullptr;
	tree.cursize = 0;
}
Result FindKey(BTree& tree, KeyType key)
{
	Result res = { nullptr,-1,false };
	BNode* ptr = tree.root;
	while (ptr != nullptr)
	{
		ptr->data[0].key = key;
		int i = ptr->num;
		while (i >= 0 && key < ptr->data[i].key)
		{
			--i;
		}
		res.ptr = ptr;
		res.index = i;
		if (i > 0 && key == ptr->data[i].key)
		{
			res.tag = true;
			break;
		}
		ptr = ptr->sub[i];
	}
	return res;
}
BNode* MakeRoot(const ElemType& item, BNode* left, BNode* right)
{
	BNode* s = Buynode();
	s->num = 1;
	s->parent = nullptr;
	s->data[1] = item;
	s->sub[0] = left;
	if (left != nullptr)left->parent = s;
	s->sub[1] = right;
	if (right != nullptr)right->parent = s;
	return s;
}
void Insert_Item(BNode* ptr, int pos, const ElemType& item, BNode* right)
{
	for (int i = ptr->num; i > pos; --i)
	{
		ptr->data[i + 1] = ptr->data[i];
		ptr->sub[i + 1] = ptr->sub[i];
	}
	ptr->data[pos + 1] = item;
	ptr->sub[pos + 1] = right;
	ptr->num += 1;
}
ElemType Move_Item(BNode* s, BNode* ptr, int pos)
{
	for (int i = 0, j = pos + 1; j <= ptr->num; ++i, ++j)
	{
		s->data[i] = ptr->data[j];
		s->sub[i] = ptr->sub[j];
		if (s->sub[i] != nullptr)
		{
			s->sub[i]->parent = s;
		}
	}
	s->num = MINSIZE;
	ptr->num = MINSIZE;
	s->parent = ptr->parent;
	return s->data[0];
}
BNode* Splice(BNode* ptr)
{
	BNode* s = Buynode();
	ElemType item = Move_Item(s, ptr, MINSIZE);
	if (ptr->parent == nullptr)
	{
		return MakeRoot(item, ptr, s);
	}
	BNode* pa = ptr->parent;
	int pos = pa->num;
	pa->data[0] = item;
	while (pos > 0 && item.key < pa->data[pos].key)
	{
		--pos;
	}
	Insert_Item(pa, pos, item, s);
	if (pa->num > MAXSIZE)
	{
		return Splice(pa);
	}
	else
	{
		return nullptr;
	}
}
bool Insert(BTree& tree, const ElemType& item)
{
	if (tree.root == nullptr)
	{
		tree.root = MakeRoot(item, nullptr, nullptr);
		tree.cursize = 1;
		return true;
	}
	Result res = FindKey(tree, item.key);
	if (res.ptr != nullptr && res.tag)return false;
	BNode* ptr = res.ptr;
	int pos = res.index;
	Insert_Item(ptr, pos, item, nullptr);
	if (ptr->num > MAXSIZE)
	{
		BNode* newroot = Splice(ptr);
		if (newroot != nullptr)
		{
			tree.root = newroot;
		}
	}
	tree.cursize += 1;
	return true;
}

void InOrder(BNode* ptr)// 中序遍历B-树
{
	if (ptr == nullptr)return;
	InOrder(ptr->sub[0]);
	for (int i = 1;i <= ptr->num; ++i)
	{
		cout << ptr->data[i].key;
		InOrder(ptr->sub[i]);
	}
}
int main()
{
	BTree myt;
	Init_BTree(myt);
	char ch[] = { "qwe1rty4u5io2pas6dfg3hjklz7xc8v9bnmabcdef" };
	int i = 0;
	while (ch[i] != '\0')
	{
		ElemType item = { ch[i],nullptr };
		cout << Insert(myt, item);
		++i;
	}
	cout << endl;
	InOrder(myt.root);
	cout << endl;
	return 0;
}
```

## 5.8 B+树

B+树是B-树的改进方案。对于一颗B-树，其缺点在数据庞大时较为明显：由于结点将数据和分支做在一起，这样叶子结点的分支域不起作用，白白浪费空间。B+树将结点分为数据类型和分支类型，并且规定所有叶子结点均为数据类型，其余结点均为分支类型。这样做首先提高了空间利用率，不会导致过多的内存占用。同时，所有的叶子结点通过一个双向链表链接，这样在查询的时候B+树可以通过两种方式进行查询：一种采用传统方式从根结点自上而下查找到叶子结点，另一种方式直接从双向链表的首部依次查找。

```c++
#define M 5
#define BRCHMAX (M-1)
#define BRCHMIN (M/2)
#define LEAFMAX (M)
#define LEAFMIN (M/2+1)
typedef int KeyType;
typedef struct {}Record;
typedef enum { BRCH = 1, LEAF = 2 } NodeType;

typedef struct BNode
{
	int num;
	BNode* parent;
	NodeType utype;
	KeyType key[M + 1];
	union
	{
		struct
		{
			Record* recptr[M + 1];
			BNode* prev, * next;
		};
		BNode* sub[M + 1];
	};
}BNode;
typedef struct
{
	struct BNode* root;// 根查询
	struct BNode* first;// 块查询
	int cursize;
}BTree;
typedef struct
{
	struct BNode* ptr;
	int index;
	bool tag;
}Result;
BNode* Buynode()
{
	BNode* s = (BNode*)malloc(sizeof(BNode));
	if (nullptr == s)exit(1);
	memset(s, 0, sizeof(BNode));
	return s;
}
BNode* BuyLeaf()
{
	BNode* s = Buynode();
	s->parent = nullptr;
	s->utype = LEAF;
	return s;
}
BNode* BuyBrch()
{
	BNode* s = Buynode();
	s->parent = nullptr;
	s->utype = BRCH;
	return s;
}
void Init_BTree(BTree& tree)
{
	tree.first = nullptr;
	tree.root = nullptr;
	tree.cursize = 0;
}
BNode* MakeRoot(const KeyType kx, BNode* left, BNode* right)
{
	BNode* s = Buynode();
	s->num = 1;
	s->parent = nullptr;
	s->utype = BRCH;
	s->key[1] = kx;
	s->sub[0] = left;
	if (left != nullptr) left->parent = s;
	s->sub[1] = right;
	if (right != nullptr) right->parent = s;
	return s;
}
Result FindLeaf(BNode* ptr, KeyType kx)
{
	Result res = { nullptr,-1,false };
	BNode* p = ptr;
	while (p != nullptr && p->next != nullptr && kx > p->key[p->num - 1])
	{
		p = p->next;
	}
	if (p == nullptr) return res;
	int pos = p->num - 1;
	while (pos >= 0 && kx < p->key[pos])
	{
		--pos;
	}
	res.ptr = p;
	res.index = pos;
	if (pos < 0 && p->prev != nullptr)
	{
		res.ptr = p->prev;
		res.index = p->prev->num - 1;
	}
	else if (pos >= 0 && kx == p->key[pos])
	{
		res.tag = true;
	}
	return res;
}
Result FindRoot(BNode* ptr, KeyType kx)
{
	Result res = { nullptr,-1,false };
	BNode* p = ptr;
	while (p != nullptr && p->utype == BRCH)
	{
		p->key[0] = kx;
		int i = p->num;
		while (kx < p->key[i]) --i;
		p = p->sub[i];
	}
	res = FindLeaf(p, kx);
	return res;
}
KeyType Move_Brch_Item(BNode* s, BNode* ptr)
{
	for (int i = 0, j = LEAFMIN + 1; j <= ptr->num; ++i, ++j)
	{
		s->key[i] = ptr->key[j];
		s->sub[i] = ptr->sub[j];
		if (s->sub[i] != nullptr)
		{
			s->sub[i]->parent = s;
		}
	}
	s->num = LEAFMIN;
	ptr->num = LEAFMIN;
	s->parent = ptr->parent;
	return s->key[0];
}
void Insert_Brch_Item(BNode* ptr, int pos, KeyType kx, BNode* right)
{
	for (int i = ptr->num; i > pos; --i)
	{
		ptr->key[i + 1] = ptr->key[i];
		ptr->sub[i + 1] = ptr->sub[i];
	}
	ptr->key[pos + 1] = kx;
	ptr->sub[pos + 1] = right;
	ptr->num += 1;
}
BNode* Splice_Brch(BNode* ptr)
{
	BNode* s = BuyBrch();
	KeyType kx = Move_Brch_Item(s, ptr);
	if (ptr->parent == nullptr)
	{
		return MakeRoot(kx, ptr, s);
	}
	BNode* pa = ptr->parent;
	int pos = pa->num;
	pa->key[0] = kx;
	while (pos > 0 && kx < pa->key[pos])
	{
		--pos;
	}
	Insert_Brch_Item(pa, pos, kx, s);
	if (pa->num > LEAFMAX)
	{
		return Splice_Brch(pa);
	}
	else
	{
		return nullptr;
	}
}
void Insert_Leaf_Item(BNode* ptr, int pos, KeyType kx, Record* rec)
{
	for (int i = ptr->num - 1; i > pos; --i)
	{
		ptr->key[i + 1] = ptr->key[i];
		ptr->recptr[i + 1] = ptr->recptr[i];
	}
	ptr->key[pos + 1] = kx;
	ptr->recptr[pos + 1] = rec;
	ptr->num += 1;
}
KeyType Move_Leaf_Item(BNode* s, BNode* ptr)
{
	for (int i = 0, j = LEAFMIN; j < ptr->num; ++i, ++j)
	{
		s->key[i] = ptr->key[j];
		s->recptr[i] = ptr->recptr[j];
	}
	s->num = LEAFMIN;
	ptr->num = LEAFMIN;
	s->parent = ptr->parent;
	s->next = ptr->next;
	s->prev = ptr;
	ptr->next = s;
	if (s->next != nullptr)
	{
		s->next->prev = s;
	}
	return s->key[0];
}
BNode* Splice_Leaf(BNode* ptr)
{
	BNode* s = BuyLeaf();
	KeyType kx = Move_Leaf_Item(s, ptr);
	if (ptr->parent == nullptr)
	{
		return MakeRoot(kx, ptr, s);
	}
	BNode* pa = ptr->parent;
	int pos = pa->num;
	pa->key[0] = kx;
	while (pos > 0 && kx < pa->key[pos])
	{
		--pos;
	}
	Insert_Brch_Item(pa, pos, kx, s);
	if (pa->num > BRCHMAX)
	{
		return Splice_Brch(pa);
	}
	else
	{
		return nullptr;
	}
}
bool Insert(BTree& tree, KeyType kx, Record* rec)
{
	if (tree.root == nullptr)
	{
		BNode* s = BuyLeaf();
		s->key[0] = kx;
		s->recptr[0] = rec;
		s->num = 1;
		tree.root = tree.first = s;
		return true;
	}
	Result resf = FindLeaf(tree.first, kx);
	if (resf.ptr == nullptr)
	{
		cout << "unknow error" << endl;
		return false;
	}
	if (resf.tag)
	{
		cout << "duplicate value" << endl;
		return false;
	}
	BNode* ptr = resf.ptr;
	int pos = resf.index;
	Insert_Leaf_Item(ptr, pos, kx, rec);
	if (ptr->num > LEAFMAX)
	{
		BNode* newroot = Splice_Leaf(ptr);
		if (newroot != nullptr)
		{
			tree.root = newroot;
		}
	}
	return true;
}
int main()
{
	int ar[] = { 23,33,12,10,48,50 };
	int n = sizeof(ar) / sizeof(ar[0]);
	BTree myt;
	Init_BTree(myt);
	int i = 0;
	while (i < n)
	{
		Insert(myt, ar[i], nullptr);
		++i;
	}
	return 0;
}
```

## 5.9 B*树

B\*树进一步从效率上进行考虑，优化B+树叶子结点的分裂逻辑，原本B+树的叶子结点一旦到达上限就会分裂出新的叶子结点存放数据，但是B\*树不会立刻分裂，而是首先通过双向链表查询左右结点的存储情况，如果两边任一结点数据域仍有空闲，就优先将数据进行转移。这种方式提高了结点的使用效率，而且减少的叶子结点的分裂次数。

# 6.图论

简单介绍图的关键性质，以及最常用的图搜索算法，最小生成树的克鲁斯卡尔算法。

## 6.1并查集

并查集是一种集合，简单来讲通过数组下标和数组元素标识若干个图形结构。使用时给出等价类，合并算法可以将两个不连通的图合并为一个连通图，由于这种性质的存在，所以可以通过并查集算法来判断一个图中是否存在环，这对后续的最小生成树算法有很大的帮助。

```c++
class UFSets
{
private:
	int* parent;
	int size;
	void print(int v)
	{
		cout << v << "\t";
		for (int i = 0; i < size; ++i)
		{
			if (parent[i] == v)
			{
				print(i);
			}
		}
	}
public:
	UFSets(int sz) :size(sz)
	{
		parent = new int[size];
		for (int i = 0; i < size; ++i)
		{
			parent[i] = -1;
		}
	}
	int FindRoot(int child)
	{
		while (parent[child] >= 0)
		{
			child = parent[child];
		}
		return child;
	}
	bool Union(int cha, int chb)
	{
		bool res = false;
		int left = FindRoot(cha);
		int right = FindRoot(chb);
		if (left != right)// 两顶点不在一个图中进行合并
		{
			parent[left] += parent[right];
			parent[right] = left;
			res = true;
		}
		return res;
	}
	void Print()
	{
		int s = 1;
		for (int i = 0; i < size; ++i)
		{
			if (parent[i] < 0)
			{
				cout << "集合" << s++ << ":" << endl;
				print(i);
				cout << endl;
			}
		}
	}
};
int main()
{
	UFSets set(12);
	set.Union(0, 4);
	set.Union(3, 1);
	set.Union(6, 10);
	set.Union(8, 9);
	set.Union(7, 4);
	set.Union(6, 8);
	set.Union(3, 5);
	set.Union(2, 11);
	set.Union(11, 0);
	set.Print();
	return 0;
}
```

## 6.2DFS算法以及BFS算法

图形结构可以通过邻接矩阵和邻接表进行抽象表示，都是通过顶点和边表示图的数据结构。对于当前的程序，我们仅考虑无权图，所以边集仅需要存储0和1即可表示两个顶点是否邻接。构建好一张图后，通过深度优先算法和广度优先算法对图形结构进行遍历。

```c++
template<class NameType, class DistType>
class Graph
{
private:
	vector<NameType> verlist;
	vector<vector<DistType> >Edges;
	int vernum;
	int edgenum;
public:
	Graph() :vernum(0), edgenum(0) {}
	~Graph() {}
	void InitGraph()
	{
		NameType ch;
		int v, u;
		cout << "请输入顶点个数：";
		cin >> vernum;
		cout << "请输入顶点信息：";
		for (int i = 0; i < vernum; ++i)
		{
			cin >> ch;
			verlist.push_back(ch);
		}
		Edges.resize(vernum);
		for (int i = 0; i < vernum; ++i)
		{
			Edges[i].resize(vernum);
		}
		cout << "请输入边的个数：";
		cin >> edgenum;
		for (int i = 0; i < edgenum; ++i)
		{
			cout << "请输入边：";
			cin >> v >> u;
			Edges[v][u] = 1;
			Edges[u][v] = 1;
		}
	}
	void PrintGraph() const
	{
		cout << "顶点信息：" << endl;
		for (auto& x : verlist)
		{
			cout << x << "\t";
		}
		cout << endl << "领接矩阵：" << endl;
		for (int i = 0; i < vernum; ++i)
		{
			for (int j = 0; j < vernum; ++j)
			{
				cout << Edges[i][j] << "\t";
			}
			cout << endl;
		}
		cout << endl;
	}
	void dfs(int v, vector<bool>& visited)
	{
		visited[v] = true;
		cout << verlist[v] << " ";
		for (int i = 0; i < vernum; ++i)
		{
			if (!visited[i] && Edges[v][i] == 1)
			{
				dfs(i, visited);
			}
		}
	}
	void DFS(int v)
	{
		vector<bool> visited(vernum, false);// 访问集
		dfs(v, visited);
	}
	void BFS(int v)// 广度优先
	{
		vector<bool> visited(vernum, false);
		queue<int> qu;
		qu.push(v);
		visited[v] = true;
		while (!qu.empty())
		{
			v = qu.front();
			qu.pop();
			cout << verlist[v] << " ";
			for (int i = 0; i < vernum; ++i)
			{
				if (!visited[i] && Edges[v][i] == 1)
				{
					qu.push(i);
					visited[i] = true;
				}
			}
		}
	}
};
int main()
{
	Graph<char, int> graph;
	graph.InitGraph();
	graph.PrintGraph();
	cout << "深度优先遍历：";
	graph.DFS(0);
	cout << endl << "广度优先遍历：";
	graph.BFS(0);
	return 0;
}
```

## 6.3最小生成树

最小生成树首先针对于有权图，然后保证生成树所有边的权值最小。克鲁斯卡尔算法可以得到一个有权图的最小生成树，要实现这个算法首先需要三个数据结构：最小堆，邻接表，并查集。其中最小堆用来给出当前权值最小的边集，并查集算法可以查找图中是否存在环。

```c++
// 最小生成树
template<class DistType>
struct MinSpanTree
{
	int head, tail;
	DistType cost;
	operator DistType() const
	{
		return cost;
	}
};
class UFSets
{
private:
	int* parent;
	int size;
public:
	UFSets(int sz) :size(sz)
	{
		parent = new int[size];
		for (int i = 0; i < size; ++i)
		{
			parent[i] = -1;
		}
	}
	int FindRoot(int child)
	{
		while (parent[child] >= 0)
		{
			child = parent[child];
		}
		return child;
	}
	bool Union(int cha, int chb)
	{
		bool res = false;
		int left = FindRoot(cha);
		int right = FindRoot(chb);
		if (left != right)
		{
			parent[left] += parent[right];
			parent[right] = left;
			res = true;
		}
		return res;
	}
};
template<class NameType, class DistType>
class Graph
{
private:
	vector<NameType> verlist;
	vector<vector<DistType> >Edges;
	int vernum;
	int edgenum;
public:
	Graph() :vernum(0), edgenum(0) {}
	~Graph() {}
	void InitGraph()
	{
		NameType ch;
		int v, u;
		DistType d;
		cout << "请输入顶点个数：";
		cin >> vernum;
		cout << "请输入顶点信息：";
		for (int i = 0; i < vernum; ++i)
		{
			cin >> ch;
			verlist.push_back(ch);
		}
		Edges.resize(vernum);
		for (int i = 0; i < vernum; ++i)
		{
			Edges[i].resize(vernum, INT_MAX);
		}
		for (int i = 0; i < vernum; ++i) Edges[i][i] = 0;
		cout << "请输入边的个数：";
		cin >> edgenum;
		for (int i = 0; i < edgenum; ++i)
		{
			cout << "请输入边和权值：";// 需要读入权值
			cin >> v >> u >> d;
			Edges[v][u] = d;
			Edges[u][v] = d;
		}
	}
	void PrintGraph() const
	{
		cout << "顶点信息：" << endl;
		for (auto& x : verlist)
		{
			cout << x << "\t";
		}
		cout << endl << "领接矩阵：" << endl;
		for (int i = 0; i < vernum; ++i)
		{
			for (int j = 0; j < vernum; ++j)
			{
				if (Edges[i][j] == INT_MAX)
				{
					cout << "$\t";
				}
				else
				{
					cout << Edges[i][j] << "\t";
				}
			}
			cout << endl;
		}
		cout << endl;
	}
	void Kruskal(vector<MinSpanTree<int> >& mst)
	{
		UFSets set(vernum);// 初始化并查集
		priority_queue<MinSpanTree<int>, vector<MinSpanTree<int> >, greater<MinSpanTree<int> > > pq;
		for (int i = 1; i < vernum; ++i)
		{
			for (int j = 0; j < i; ++j)
			{
				if (Edges[i][j] != INT_MAX)
				{
					MinSpanTree<int> e = { i,j,Edges[i][j] };
					pq.push(e);// 边集信息入优先队列
				}
			}
		}
		int i = 0;
		while (i < vernum - 1)
		{
			MinSpanTree<int> e = pq.top();// 取权值最小边
			pq.pop();
			if (set.Union(e.head, e.tail))// 判断是否存在环
			{
				mst.push_back(e);
				++i;
			}
		}
	}
};
int main()
{
	Graph<char, int> graph;
	vector<MinSpanTree<int> >mst;// 保存最小生成树的容器
	graph.InitGraph();
	graph.PrintGraph();
	graph.Kruskal(mst);// kruskal算法
	for (auto& x : mst)
	{
		cout << x.head << " > " << x.tail << " : " << x.cost << endl;
	}
	return 0;
}
```
