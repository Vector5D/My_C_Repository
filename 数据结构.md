# 1.线性表

## 1.1顺序表

顺序表是线性表的一种，以数组作为基本实现方式。其中数组长度固定成为定长线性表，长度可变则成为变长顺序表。相较于定长顺序表，变长顺序表的用途更为广泛，所以下面给出变长顺序表的相关操作以供参考。

```c
#include<stdio.h>
#include<stdlib.h>
#include<assert.h>
#define INIT_SIZE 10//规定数组的初始长度

typedef struct SQlist {
	int* data;//动态申请内存
	int length;//线性表中当前有效元素个数
	int maxsize;//线性表中最大有效元素个数
}SQlist, * PSQlist;

void Init_List(PSQlist plist){
    //初始化顺序表
	assert(plist != nullptr);
	plist->data = (int*)malloc(sizeof(int) * INIT_SIZE);//动态内存分配
	if (plist->data == nullptr)exit(1);
	plist->length = 0;//设定初始有效元素个数为零
	plist->maxsize = INIT_SIZE;//设定最大有效元素长度
}

bool Isempty(PSQlist plist) {
    //判断顺序表是否为空，其实就是判断其有效元素个数是否为零
	assert(plist != nullptr);
	return plist->length == 0;
}

bool Isfull(PSQlist plist) {
    //如果当前顺序表中有效元素的个数与最大有效元素个数相同则满
	assert(plist != nullptr);
	return plist->length == plist->maxsize;
}

void Inc(PSQlist plist) {
	//每当顺序表满的时候，应该使用扩容函数扩容
	int* pnew;
	pnew = (int*)realloc(plist->data, sizeof(int) * plist->maxsize * 2);
    //规定扩充的内存相当于之前空间的2倍
	if (pnew == nullptr)exit(1);
	plist->data = pnew;
	plist->maxsize *= 2;//修改顺序表当前最大有效元素个数
}

int Search(PSQlist plist, int val) {
    //查找指定数值的元素并返回其下标
	assert(plist != nullptr);
	for (int i = 0;i < plist->length;i++) {
		if (val == plist->data[i]) {
			return i;
		}
	}
	return -1;//如果没有这个数值则返回-1表示查找失败
}

bool Insert(PSQlist plist, int pos, int val) {
    //在指定位置插入指定数值的元素
	assert(plist != nullptr);
	if (pos < 0 || pos > plist->length) {
        //判断插入位置的合法性
		return false;
	}
	if (Isfull(plist)) {
        //如果顺序表满，则进行扩容
		Inc(plist);
	}
	for (int i = plist->length - 1;i >= pos;i--) {
        //到插入位置为止，从后向前依次挪动元素
		plist->data[i + 1] = plist->data[i];
	}
	plist->data[pos] = val;
	plist->length += 1;
	return true;
}

bool Del_Pos(PSQlist plist, int pos) {
    //删除指定位置的元素
	assert(plist != nullptr);
	if (pos < 0 || pos >= plist->length) {
		return false;
	}
	for (int i = pos;i < plist->length - 1;i++) {
        //从删除位置开始，从前向后挪动元素
		plist->data[i] = plist->data[i + 1];
	}
	plist->length -= 1;
	return true;
}

bool Del_Val(PSQlist plist, int val) {
    //删除指定数值的元素
	assert(plist != nullptr);
	int i = Search(plist, val);//通过数值找到元素下标
	if (i == -1) {
		return false;
	}
	Del_Pos(plist, i);//通过元素下标删除对应元素
	return true;
}

void Print_List(PSQlist plist) {
    //打印函数
	assert(plist != nullptr);
	for (int i = 0; i < plist->length;i++) {
		printf("%d ", plist->data[i]);
	}
	printf("\n");
}

void Clear_List(PSQlist plist) {
    //清空函数，将有效元素个数置为零则视为清空
	assert(plist != nullptr);
	plist->length = 0;
}

void Destroy_List(PSQlist plist) {
    //销毁函数，释放堆区申请的内存，并将对应指针置为空
	assert(plist != nullptr);
	free(plist->data);
	plist->data = nullptr;
	plist->length = 0;
	plist->maxsize = 0;
}

int Get_Length(PSQlist plist) {
    //获取顺序表当前有效元素的个数
	assert(plist != nullptr);
	return plist->length;
}
```

## 1.2链表

链表是实现线性表的第二种形式，其中又可以分为单链表、循环单链表、双链表、循环双链表等。这里给出循环单链表以及循环双链表的代码实现以供参考。

### 1.2.1循环单链表

```c
#include<stdio.h>
#include<stdlib.h>
#include<assert.h>

typedef int ELEM_TYPE;
typedef struct CNode {
	//单向循环链表
	struct CNode* next;
	ELEM_TYPE data;
}CNode, * PCList;

void Init_List(PCList pclist){
	//初始化循环链表
	assert(pclist != nullptr);
	if (pclist == nullptr)
		exit(EXIT_FAILURE);
	pclist->next = pclist;
}

bool Insert_Head(PCList pclist, ELEM_TYPE val) {
	//头插法
	assert(pclist != nullptr);
	if (pclist == nullptr)
		exit(EXIT_FAILURE);

	CNode* p = (CNode*)malloc(sizeof(CNode));
	if (p == nullptr) {
		printf("malloc failed\n");
		exit(EXIT_FAILURE);
	}

	p->data = val;
	p->next = pclist->next;
	pclist->next = p;

	return true;
}

int Get_Length(PCList pclist) {
	//获得循环链表的长度
	assert(pclist != nullptr);
	if (pclist == nullptr)
		exit(EXIT_FAILURE);

	CNode* p = pclist;
	int count = 0;
	while (p->next != pclist) {
		count += 1;
		p = p->next;
	}

	return count;
}

bool Insert_Tail(PCList pclist, ELEM_TYPE val) {
	//尾插法
	assert(pclist != nullptr);
	if (pclist == nullptr)
		exit(EXIT_FAILURE);

	CNode* p = pclist;
	while (p->next != pclist) {
		p = p->next;
	}

	CNode* q = (CNode*)malloc(sizeof(CNode));
	if (q == nullptr) {
		printf("malloc failed\n");
		exit(EXIT_FAILURE);
	}

	q->data = val;
	q->next = p->next;
	p->next = q;

	return true;
}

bool Del_Head(PCList pclist) {
	//从头部删除
	assert(pclist != nullptr);
	if (pclist == nullptr)
		exit(EXIT_FAILURE);

	if (Get_Length(pclist) == 0) {
		printf("empty list\n");
		return false;
	}

	CNode* p = pclist->next;
	pclist->next = p->next;
	free(p);
	p = nullptr;

	return true;
}

bool Del_Tail(PCList pclist) {
	//从尾部删除
	assert(pclist != nullptr);
	if (pclist == nullptr)
		exit(EXIT_FAILURE);

	if (Get_Length(pclist) == 0) {
		printf("empty list\n");
		return false;
	}

	CNode* p = pclist;
	int size = Get_Length(pclist);
	int i = 1;
	while (i < size) {
		p = p->next;
		i += 1;
	}

	CNode* q = p->next;
	p->next = q->next;
	free(q);
	q = nullptr;

	return true;
}

CNode* Search_Val(PCList pclist, ELEM_TYPE val) {
	//查找并返回值为val的结点
	assert(pclist != nullptr);
	if (pclist == nullptr)
		exit(EXIT_FAILURE);

	CNode* p = pclist->next;
	while (p != pclist) {
		if (p->data == val) {
			return p;
		}
		p = p->next;
	}
	return nullptr;
}

CNode* Search_Val_Prior(PCList pclist, ELEM_TYPE val) {
	//查找并返回值为val结点的前驱结点
	assert(pclist != nullptr);
	if (pclist == nullptr)
		exit(EXIT_FAILURE);

	CNode* p = pclist;
	while (p->next != pclist) {
		if (p->next->data == val) {
			return p;
		}
		p = p->next;
	}
	return nullptr;
}

CNode* Search_Val_Next(PCList pclist, ELEM_TYPE val) {
	//查找并返回值为val结点的后继结点
	CNode* p = Search_Val(pclist, val);
	if (p == nullptr)return nullptr;
	return p->next;
}

bool Insert_Val(PCList pclist, int pos, ELEM_TYPE val) {
	//指定位置插入值为val的结点
	assert(pclist != nullptr);
	if (pclist == nullptr)
		exit(EXIT_FAILURE);

	if (pos < 0 || pos > Get_Length(pclist)) {
		printf("pos error\n");
		return false;
	}

	CNode* p = pclist;
	for (int i = 0;i < pos;i++) {
		p = p->next;
	}

	CNode* q = (CNode*)malloc(sizeof(CNode));
	if (q == nullptr) {
		printf("malloc error\n");
		exit(EXIT_FAILURE);
	}

	q->data = val;
	q->next = p->next;
	p->next = q;

	return true;
}

bool Del_Pos(PCList pclist, int pos) {
	//删除指定位置的结点
	assert(pclist != nullptr);
	if (pclist == nullptr)
		exit(EXIT_FAILURE);

	if (pos < 0 || pos >= Get_Length(pclist)) {
		printf("pos error\n");
		return false;
	}

	CNode* p = pclist;
	for (int i = 0;i < pos;i++) {
		p = p->next;
	}

	CNode* q = p->next;
	p->next = q->next;
	free(q);
	q = nullptr;

	return true;
}

bool Del_Val(PCList pclist, ELEM_TYPE val) {
	//删除第一个指定数据的结点
	assert(pclist != nullptr);
	if (pclist == nullptr)
		exit(EXIT_FAILURE);

	CNode* p = Search_Val_Prior(pclist, val);
	if (p == nullptr) {
		printf("can't find val\n");
		return false;
	}

	CNode* q = p->next;
	p->next = q->next;
	free(q);
	q = nullptr;

	return true;
}

void Print_List(PCList pclist) {
	//打印链表
	assert(pclist != nullptr);
	if (pclist == nullptr)
		exit(EXIT_FAILURE);

	if (Get_Length(pclist) == 0) {
		printf("this is an empty clist\n");
		return;
	}

	CNode* p = pclist->next;
	while (p != pclist) {
		printf("%5d", p->data);
		p = p->next;
	}
	printf("\nlength = %d\n", Get_Length(pclist));
}

void Clear_List(PCList pclist) {
	//清空链表
	assert(pclist != nullptr);
	if (pclist == nullptr)
		exit(EXIT_FAILURE);

	while (pclist->next != pclist) {
		Del_Head(pclist);
	}
}

void Destroy_List(PCList& pclist) {
	//销毁链表
	assert(pclist != nullptr);
	if (pclist == nullptr)
		exit(EXIT_FAILURE);

	Clear_List(pclist);
	free(pclist);
	pclist = nullptr;
	printf("clist is already destroyed\n");
}
```

### 1.2.2循环双链表（一）

```c
#include<stdio.h>
#include<stdlib.h>
#include<assert.h>

typedef int ELEM_TYPE
typedef struct DCNode {
    //循环双向链表
	ELEM_TYPE data;
	struct DCNode* next;
	struct DCNode* prior;
}DCNode, * PDCList;

void Init_Dlist(PDCList pdclist) {
    //初始化双向循环链表
	assert(pdclist != nullptr);
	if (pdclist == nullptr)exit(EXIT_FAILURE);
	//在没有结点的情况下，将头结点的前驱和后继指向自己
	pdclist->next = pdclist;
	pdclist->prior = pdclist;
}

bool Insert_Head(PDCList pdclist, ELEM_TYPE val) {
    //头插法
	assert(pdclist != nullptr);
	if (pdclist == nullptr)exit(EXIT_FAILURE);

	DCNode* p = (DCNode*)malloc(sizeof(DCNode));
	if (p == nullptr) {
		printf("malloc failed\n");
		exit(EXIT_FAILURE);
	}
	//注意插入时指针域之间的关系
	p->data = val;
	p->next = pdclist->next;
	p->prior = pdclist;
	pdclist->next->prior = p;
	pdclist->next = p;
	
	return true;
}

bool Insert_Tail(PDCList pdclist, ELEM_TYPE val) {
    //尾插法
	assert(pdclist != nullptr);
	if (pdclist == nullptr)exit(EXIT_FAILURE);

	DCNode* p = (DCNode*)malloc(sizeof(DCNode));
	if (p == nullptr) {
		printf("malloc failed\n");
		exit(EXIT_FAILURE);
	}
	//由于循环双向链表，我们在头结点之前插入元素等价于向尾部插入结点
	p->data = val;
	p->next = pdclist;
	p->prior = pdclist->prior;
	pdclist->prior->next = p;
	pdclist->prior = p;

	return true;
}

int Get_Length(PDCList pdclist) {
    //得到双向链表的长度
	assert(pdclist != nullptr);
	if (pdclist == nullptr)exit(EXIT_FAILURE);

	DCNode* p = pdclist;
	int count = 0;
	while (p->next != pdclist) {
        //注意循环结束条件
		p = p->next;
		count += 1;
	}
	return count;
}

bool Insert_Val(PDCList pdclist, int pos, ELEM_TYPE val) {
    //在指定位置插入指定数值的结点
	assert(pdclist != nullptr);
	if (pdclist == nullptr)exit(EXIT_FAILURE);

	if (pos < 0 || pos > Get_Length(pdclist)) {
		printf("pos error\n");
		return false;
	}
	//定位指定位置的前驱结点
	DCNode* p = pdclist;
	for (int i = 0;i < pos;i++) {
		p = p->next;
	}

	DCNode* q = (DCNode*)malloc(sizeof(DCNode));
	if (q == nullptr) {
		printf("malloc failed\n");
		exit(EXIT_FAILURE);
	}

	q->data = val;
	q->prior = p;
	q->next = p->next;
	p->next->prior = q;
	p->next = q;

	return true;
}

bool Del_Head(PDCList pdclist) {
    //从头部删除
	assert(pdclist != nullptr);
	if (pdclist == nullptr)exit(EXIT_FAILURE);

	if (Get_Length(pdclist) == 0) {
		printf("empty list\n");
		return false;
	}

	DCNode* p = pdclist->next;
	p->prior->next = p->next;
	p->next->prior = p->prior;
	free(p);
	p = nullptr;

	return true;
}

bool Del_Tail(PDCList pdclist) {
    //从尾部删除
	assert(pdclist != nullptr);
	if (pdclist == nullptr)exit(EXIT_FAILURE);

	if (Get_Length(pdclist) == 0) {
		printf("empty list\n");
		return false;
	}

	DCNode* p = pdclist->prior;
	p->prior->next = p->next;
	p->next->prior = p->prior;
	free(p);
	p = nullptr;

	return true;
}

bool Del_Pos(PDCList pdclist, int pos) {
    //删除指定位置的结点元素
	assert(pdclist != nullptr);
	if (pdclist == nullptr)exit(EXIT_FAILURE);

	if (pos < 0 || pos >= Get_Length(pdclist)) {
		printf("pos error\n");
		return false;
	}
	//定位指定位置的前驱结点
	DCNode* p = pdclist;
	for (int i = 0;i < pos;i++) {
		p = p->next;
	}
	//删除指定结点
	DCNode* q = p->next;
	q->prior->next = q->next;
	q->next->prior = q->prior;
	free(q);
	q = nullptr;

	return true;
}

DCNode* Search_Val(PDCList pdclist, ELEM_TYPE val) {
    //查询等于指定数值的结点并将其返回
	assert(pdclist != nullptr);
	if (pdclist == nullptr)exit(EXIT_FAILURE);

	DCNode* p = pdclist->next;
	while (p != pdclist) {
		if (p->data == val) {
			return p;
		}
		p = p->next;
	}
	return nullptr;
}

DCNode* Search_Val_Prior(PDCList pdclist, ELEM_TYPE val) {
    //查询等于指定数值的结点并返回其前驱
	DCNode* p = Search_Val(pdclist,val);
	if (p == nullptr)return nullptr;
	return p->prior;
}

DCNode* Search_Val_Next(PDCList pdclist, ELEM_TYPE val) {
    //查询等于指定数值的结点并返回其后继
	DCNode* p = Search_Val(pdclist, val);
	if (p == nullptr)return nullptr;
	return p->next;
}

bool Del_Val(PDCList pdclist, ELEM_TYPE val) {
    //删除第一个等于指定数值的结点
	assert(pdclist != nullptr);
	if (pdclist == nullptr)exit(EXIT_FAILURE);
	//通过指定数值找到对应结点
	DCNode* p = Search_Val(pdclist, val);
	if (p == nullptr) {
		printf("can't find val\n");
		return false;
	}
	//删除该结点
	p->prior->next = p->next;
	p->next->prior = p->prior;
	free(p);
	p = nullptr;

	return true;
}

void Print_Dlist(PDCList pdclist) {
    //打印函数
	assert(pdclist != nullptr);
	if (pdclist == nullptr)exit(EXIT_FAILURE);

	if (Get_Length(pdclist) == 0) {
		printf("this is an empty list\n");
		return;
	}

	DCNode* p = pdclist->next;
	while (p != pdclist) {
		printf("%5d", p->data);
		p = p->next;
	}
	printf("\nlength = %d\n", Get_Length(pdclist));
}

void Clear_Dlist(PDCList pdclist) {
    //清空函数，循环调用从头删除函数直到链表为空
	assert(pdclist != nullptr);
	if (pdclist == nullptr)exit(EXIT_FAILURE);

	while (pdclist->next != pdclist) {
		Del_Head(pdclist);
	}
}

void Destroy_Dlist(PDCList& pdclist) {
    //销毁函数，清空链表之后释放头结点
	assert(pdclist != nullptr);
	if (pdclist == nullptr)
		exit(EXIT_FAILURE);

	Clear_Dlist(pdclist);
	free(pdclist);
	pdclist = nullptr;
	printf("dlist is already destroyed\n");
}
```

### 1.2.3循环双链表（二）

```c
#include<stdio.h> 
#include<stdlib.h>	 
#include<assert.h>
#include<string.h>

typedef int ElemType;
typedef struct ListNode {
	ElemType data;
	struct ListNode* priv;
	struct ListNode* next;
}ListNode;
typedef struct {
	struct ListNode* head;
	int cursize;
}DuLinkList;

static ListNode* Buynode(ListNode* pre, ListNode* p) {
    //购买结点
	ListNode* s = (ListNode*)malloc(sizeof(ListNode));
	if (s == nullptr)exit(1);
	memset(s, 0, sizeof(ListNode));
    //如果是头结点，就将其指针域全部指向自己
	s->next = (p == nullptr) ? s : p;
	s->priv = (pre == nullptr) ? s : pre;
	return s;
}
static void Freenode(ListNode* p) {
    //释放结点
	free(p);
}
void Init_List(DuLinkList* plist) {
    //初始化链表
	assert(plist != nullptr);
	plist->head = Buynode();
	plist->cursize = 0;
}
void Print_List(DuLinkList* plist) {
    //打印链表
	assert(plist != nullptr);
	if (plist->head == nullptr) {
		printf("\"the list is already destroyed\"");
		exit(1);
	}
	else if (plist->cursize == 0) {
		printf("\"this is an empty list\"\n");
		return;
	}
	ListNode* p = plist->head->next;
	while (p != plist->head) {
		printf("%5d", p->data);
		p = p->next;
	}
	printf("\n");
}
int GetSize(DuLinkList* plist) {
    //获取当前链表的长度
	assert(plist != nullptr);
	return plist->cursize;
}
bool Is_Empty(DuLinkList* plist) {
    //判空
	return GetSize(plist) == 0;
}
ListNode* FindValue(DuLinkList* plist, ElemType val) {
    //找到指定数值并返回对应结点
	assert(plist != nullptr);
	ListNode* p = plist->head->next;
	while (p != plist->head && p->data != val) {
		p = p->next;
	}
	if (p == plist->head)p = nullptr;
	return p;
}
ListNode* FindPos(DuLinkList* plist, int pos) {
    //找到指定位置并返回对应结点
	assert(plist != nullptr);
	if (pos < 1 || pos > plist->cursize + 1)return nullptr;
	ListNode* p = plist->head;
	while (pos != 0) {
		p = p->next;
		pos -= 1;
	}
	return p;
}
void Insert(DuLinkList* plist, ListNode* p, ElemType val) {
    //在指定结点的前面插入
	assert(plist != nullptr);
	if (p != nullptr) {
		ListNode* s = Buynode(p->priv, p);
		s->data = val;
		p->priv->next = s;
		p->priv = s;
		plist->cursize += 1;
	}
}
bool Insert_Item(DuLinkList* plist, int pos, ElemType val) {
    //给出指定位置和数值，并在该位置对应结点的前面插入
	assert(plist != nullptr);
	ListNode* p = FindPos(plist, pos);
	if (p == nullptr)return false;
	Insert(plist, p, val);
	return true;
}
void push_back(DuLinkList* plist, ElemType val) {
    //尾插法
	Insert(plist, plist->head, val);
}
void push_front(DuLinkList* plist, ElemType val) {
    //头插法
	Insert(plist, plist->head->next, val);
}
void Insert_Ar(DuLinkList* plist, int pos, ElemType* ar, int n) {
    //在指定位置插入数组
	for (int i = 0;i < n;i++) {
		Insert_Item(plist, pos, ar[i]);
	}
}
void Insert_Val(DuLinkList* plist, int pos, ElemType val, int n) {
    //在指定位置插入若干相同元素
	for (int i = 0;i < n;i++) {
		Insert_Item(plist, pos, val);
	}
}
void Erase(DuLinkList* plist, ListNode* p) {
    //删除指定结点
	assert(plist != nullptr);
	if (p != nullptr) {
		p->priv->next = p->next;
		p->next->priv = p->priv;
		Freenode(p);
		p = nullptr;
		plist->cursize -= 1;
	}
}
bool Erase_Pos(DuLinkList* plist, int pos) {
    //删除指定位置的结点
	assert(plist != nullptr);
	ListNode* p = FindPos(plist, pos);
	if (p == nullptr)return false;
	Erase(plist, p);
	return true;
}
void pop_back(DuLinkList* plist) {
    //从尾部删除
	Erase(plist, plist->head->priv);
}
void pop_front(DuLinkList* plist) {
    //从头部删除
	Erase(plist, plist->head->next);
}
void remove(DuLinkList* plist, ElemType val) {
    //删除第一个等于指定数值的结点
	assert(plist != nullptr);
	ListNode* p = FindValue(plist, val);
	if (p == nullptr)return;
	Erase(plist, p);
}
void remove_all(DuLinkList* plist, ElemType val) {
    //删除所有等于指定数值的结点
	assert(plist != nullptr);
	ListNode* p = plist->head;
	while (p->next != plist->head) {
		if (p->next->data == val) {
			Erase(plist, p->next);
		}
		else {
			p = p->next;
		}
	}
}
void Clear_List(DuLinkList* plist) {
    //清空链表
	assert(plist != nullptr);
	while(plist->cursize != 0) {
		Erase(plist, plist->head->next);
	}
}
void Destroy_List(DuLinkList* plist) {
    //销毁链表
	assert(plist != nullptr);
	Clear_List(plist);
	Freenode(plist->head);
	plist->head = nullptr;
}
```

## 1.3栈

简单来说，栈是操作受限的线性表。其规定只能从数据的一端进行删除和插入，由于这样的特性，对于栈的入栈和出栈时间复杂度均为常数级，相对于普通的线性表时间复杂度低。

### 1.3.1顺序栈

#### 头文件（Stack.h）

```c
//"Stack.h"
#pragma once
#include<stdio.h>
#include<stdlib.h>
#include<assert.h>
#define INITSIZE 10
typedef int ElemType;
typedef struct Stack {
	ElemType* base;
	int top;//栈顶指针
	int stacksize;
}Stack, * pStack;
//顺序栈
void Init_Stack(pStack pstack);//初始化栈
bool Push(pStack pstack, ElemType val);//入栈
bool Pop(pStack pstack, ElemType* e);//出栈，并获取出栈元素的值
bool Get_Top(pStack pstack, ElemType* e);//获取栈顶元素的值
int Get_Length(pStack pstack);//获取当前有效元素的个数
bool IsEmpty(pStack pstack);//判空
bool IsFull(pStack pstack);//判满
static void Inc(pStack pstack);//如果栈满，则进行扩容
void Clear(pStack pstack);//清空栈
void Destroy(pStack pstack);//销毁栈
void Print_Stack(pStack pstack);//打印栈
```

#### 源文件

```c
#include"Stack.h"

void Init_Stack(pStack pstack) {
	assert(pstack != nullptr);
	if (pstack == nullptr)return;
	pstack->base = (ElemType*)malloc(sizeof(ElemType) * INITSIZE);
	if (pstack->base == nullptr) {
		printf("malloc filed\n");
		exit(EXIT_FAILURE);
	}
	pstack->top = 0;//栈顶指针指向将要插入元素的位置
	pstack->stacksize = INITSIZE;
}
bool Push(pStack pstack, ElemType e) {
	assert(pstack != nullptr);
	if (pstack == nullptr)return false;
	if (IsFull(pstack)) {
		Inc(pstack);
	}
	pstack->base[pstack->top] = e;//首先向栈顶指针指向的位置插入元素
	pstack->top += 1;//再将栈顶指针的位置加一
	return true;
}
bool Pop(pStack pstack, ElemType* e) {
	assert(pstack != nullptr);
	if (pstack == nullptr)return false;
	if (IsEmpty(pstack)) {
		printf("empty stack\n");
		return false;
	}	
	pstack->top -= 1;//将栈顶指针的位置减一
	*e = pstack->base[pstack->top];//再获取出栈元素的数值
	return true;
}
bool Get_Top(pStack pstack, ElemType* e) {
	assert(pstack != nullptr);
	if (pstack == nullptr)return false;
	if (IsEmpty(pstack)) {
		printf("empty stack\n");
		return false;
	}
	*e = pstack->base[pstack->top - 1];//注意这里没有更改栈顶指针的位置
	return true;
}
int Get_Length(pStack pstack) {
	assert(pstack != nullptr);
	if (pstack == nullptr)return false;
	return pstack->top;
}
bool IsEmpty(pStack pstack) {
	return pstack->top == 0;
}
bool IsFull(pStack pstack) {
	return pstack->top == pstack->stacksize;
}
static void Inc(pStack pstack) {
	ElemType* pnew = (ElemType*)realloc(pstack->base, sizeof(ElemType) * pstack->stacksize * 2);
	if (pnew == nullptr) {
		printf("realloc filed\n");
		exit(EXIT_FAILURE);
	}
	pstack->base = pnew;
	pstack->stacksize *= 2;
}
void Clear(pStack pstack) {
	assert(pstack != nullptr);
	if (pstack == nullptr)return;
	pstack->top = 0;
}
void Destroy(pStack pstack) {
	assert(pstack != nullptr);
	if (pstack == nullptr)return;
	Clear(pstack);
	free(pstack->base);
	pstack->base = nullptr;
	pstack->top = 0;
	pstack->stacksize = 0;
	printf("stack is already destroyed\n");
}
void Print_Stack(pStack pstack) {
	assert(pstack != nullptr);
	if (pstack == nullptr)return;
	for (int i = 0;i < pstack->top;i++) {
		printf("%d ", pstack->base[i]);
	}
	printf("\n");
}
//int main() {
//	Stack mystack;
//	Init_Stack(&mystack);
//	for (int i = 0;i < 20;i++) {
//		Push(&mystack, i);
//	}
//	Print_Stack(&mystack);
//	int tmp1;
//	Get_Top(&mystack, &tmp1);
//	printf("%d\n", tmp1);
//	Print_Stack(&mystack);
//	int tmp2;
//	Pop(&mystack, &tmp2);
//	printf("%d\n", tmp2);
//	Print_Stack(&mystack);
//	printf("length = %d\n", Get_Length(&mystack));
//	Clear(&mystack);
//	printf("length = %d\n", Get_Length(&mystack));
//	Destroy(&mystack);
//}
```

### 1.3.2链栈

#### 头文件（LStack.h）

```c
//"LStack.h"
#pragma once
#include<stdio.h>
#include<stdlib.h>
#include<assert.h>
typedef int ElemType;
typedef struct LStack {
	ElemType data;
	struct LStack* next;
}LStack, * pLStack;
//链栈
void Init_Stack(pLStack pstack);//初始化栈
bool Push(pLStack pstack, ElemType val);//入栈
bool Pop(pLStack pstack, ElemType* e);//出栈，并获取出栈元素的值
bool Get_Top(pLStack pstack, ElemType* e);//获取栈顶元素的值
int Get_Length(pLStack pstack);//获取当前有效元素的个数
bool IsEmpty(pLStack pstack);//判空
void Clear(pLStack pstack);//清空栈
void Destroy(pLStack& pstack);//销毁栈
void Print_Stack(pLStack pstack);//打印栈
```



#### 源文件

```c
#include"Test7_31.h"

void Init_Stack(pLStack plstack) {
	assert(plstack != nullptr);
	if (plstack == nullptr)return;
	plstack->next = nullptr;
}
bool Push(pLStack plstack, ElemType val) {
	assert(plstack != nullptr);
	if (plstack == nullptr)return false;
	LStack* p = (LStack*)malloc(sizeof(LStack));//申请新的结点
	if (p == nullptr)return false;
	p->data = val;
	p->next = plstack->next;//头插方式入栈
	plstack->next = p;
	return true;
}
bool Pop(pLStack plstack, ElemType* e) {
	assert(plstack != nullptr);
	if (plstack == nullptr)return false;
	if (IsEmpty(plstack)) {
		printf("empty stack\n");
		return false;
	}
	*e = plstack->next->data;
	LStack* p = plstack->next;//释放头结点后的第一个结点视为出栈
	plstack->next = p->next;
	free(p);
	p = nullptr;
	return true;
}
bool Get_Top(pLStack plstack, ElemType* e) {
	assert(plstack != nullptr);
	if (plstack == nullptr)return false;
	if (IsEmpty(plstack)) {
		printf("empty stack\n");
		return false;
	}
	*e = plstack->next->data;
	return true;
}
int Get_Length(pLStack plstack) {
	int count = 0;
	LStack* p = plstack->next;
	while (p != nullptr) {
		count += 1;
		p = p->next;
	}
	return count;
}
bool IsEmpty(pLStack plstack) {
	return plstack->next == nullptr;
}
void Clear(pLStack plstack) {
	assert(plstack != nullptr);
	if (plstack == nullptr)return;
	while (plstack->next != nullptr) {
		LStack* p = plstack->next;
		plstack->next = p->next;
		free(p);
		p = nullptr;
	}
}
void Destroy(pLStack& plstack) {
	assert(plstack != nullptr);
	if (plstack == nullptr)return;
	Clear(plstack);
	free(plstack);
	plstack = nullptr;
	printf("stack is already destroyed\n");
}
void Print_Stack(pLStack plstack) {
	assert(plstack != nullptr);
	if (plstack == nullptr)return;
	LStack* p = plstack->next;
	while (p != nullptr) {
		printf("%d ", p->data);
		p = p->next;
	}
	printf("\n");
}
//int main() {
//	pLStack ls = (pLStack)malloc(sizeof(LStack));
//	if (ls == nullptr)exit(EXIT_FAILURE);
//	Init_Stack(ls);
//	for (int i = 0;i < 10;i++) {
//		Push(ls, i + 1);
//	}
//	Print_Stack(ls);
//	int tmp1;
//	Get_Top(ls, &tmp1);
//	printf("top->%d\n", tmp1);
//	int tmp2;
//	Pop(ls, &tmp2);
//	printf("pop->%d\n", tmp2);
//	Print_Stack(ls);
//	Destroy(ls);
//}
```

## 1.4队列

队列允许对队头和队尾进行出队和入队操作。

### 1.4.1循环队列（顺序队列）

#### 头文件（Queue.h）

```c
//"Queue.h"
#pragma once
#include<stdio.h>
#include<stdlib.h>
#include<assert.h>
#define MAXSIZE 5
typedef int ELEM_TYPE;
typedef struct Queue {
	ELEM_TYPE* base;
	int front;//队头指针
	int rear;//队尾指针
}Queue, * pQueue;
//顺序队列
void Init_Queue(pQueue pqueue);//初始化队列
bool En_Queue(pQueue pqueue, ELEM_TYPE val);//入队
bool De_Queue(pQueue pqueue, ELEM_TYPE* e);//出队，并获取出队元素的值
int Get_Length(pQueue pqueue);//获取当前有效元素的个数
bool Get_Front(pQueue pqueue, ELEM_TYPE* e);//获取队头元素的值
bool Get_Rear(pQueue pqueue, ELEM_TYPE* e);//获取队尾元素的值
bool IsEmpty(pQueue pqueue);//判空
bool IsFull(pQueue pqueue);//判满
void Clear(pQueue pqueue);//清空队列
void Destroy(pQueue pqueue);//销毁队列
void Print_Queue(pQueue pqueue);//打印队列
```

#### 源文件

```c
#include"Queue.h"

void Init_Queue(pQueue pqueue) {
	assert(pqueue != nullptr);
	if (pqueue == nullptr)return;
	pqueue->base = (ELEM_TYPE*)malloc(sizeof(ELEM_TYPE) * MAXSIZE);
	if (pqueue->base == nullptr) {
		printf("malloc failed\n");
		exit(EXIT_FAILURE);
	}
	pqueue->front = 0;
	pqueue->rear = 0;
}
bool En_Queue(pQueue pqueue, ELEM_TYPE val) {
	assert(pqueue != nullptr);
	if (pqueue == nullptr)return false;
	if (IsFull(pqueue)) {
		printf("queue is full\n");
		return false;
	}
	pqueue->base[pqueue->rear] = val;
	pqueue->rear = (pqueue->rear + 1) % MAXSIZE;
	return true;
}
bool De_Queue(pQueue pqueue, ELEM_TYPE* e) {
	assert(pqueue != nullptr);
	if (pqueue == nullptr)return false;
	if (IsEmpty(pqueue)) {
		printf("queue is empty\n");
		return false;
	}
	*e = pqueue->base[pqueue->front];
	pqueue->front = (pqueue->front + 1) % MAXSIZE;
	return true;
}
int Get_Length(pQueue pqueue) {
	assert(pqueue != nullptr);
	if (pqueue == nullptr)return false;
	int tmp = (pqueue->rear - pqueue->front + MAXSIZE) % MAXSIZE;
	return tmp;
}
bool Get_Front(pQueue pqueue,ELEM_TYPE* e) {
	assert(pqueue != nullptr);
	if (pqueue == nullptr)return false;
	if (IsEmpty(pqueue)) {
		printf("queue is empty\n");
		return false;
	}
	*e = pqueue->base[pqueue->front];
	return true;
}
bool Get_Rear(pQueue pqueue,ELEM_TYPE* e) {
	assert(pqueue != nullptr);
	if (pqueue == nullptr)return false;
	if (IsEmpty(pqueue)) {
		printf("queue is empty\n");
		return false;
	}
	*e = pqueue->base[(pqueue->rear - 1 + MAXSIZE) % MAXSIZE];
	return true;
}
bool IsEmpty(pQueue pqueue) {
	return pqueue->rear == pqueue->front;
}
bool IsFull(pQueue pqueue) {
	return (pqueue->rear + 1) % MAXSIZE == pqueue->front;
}
void Print_Queue(pQueue pqueue) {
	assert(pqueue != nullptr);
	if (pqueue == nullptr)return;
	int length = Get_Length(pqueue);
	for (int i = 0;i < length;i++) {
		printf("%d ", pqueue->base[(pqueue->front + i) % MAXSIZE]);
	}
	printf("\nqueue length = %d\n", length);
}
void Clear(pQueue pqueue) {
	assert(pqueue != nullptr);
	if (pqueue == nullptr)return;
	pqueue->front = pqueue->rear = 0;
}
void Destroy(pQueue pqueue) {
	assert(pqueue != nullptr);
	if (pqueue == nullptr)return;
	Clear(pqueue);
	free(pqueue->base);
	pqueue->base = nullptr;
	pqueue->rear = 0;
	pqueue->front = 0;
	printf("queue is already destroyed\n");
}
//int main() {
//	Queue myq;
//	Init_Queue(&myq);
//	for (int i = 0;i < 4;i++) {
//		En_Queue(&myq, i + 1);
//	}
//	Print_Queue(&myq);
//	int e;
//	De_Queue(&myq, &e);
//	Print_Queue(&myq);
//	int a1, a2;
//	Get_Front(&myq, &a1);
//	Get_Rear(&myq, &a2);
//	printf("front is %d,rear is %d\n", a1, a2);
//	En_Queue(&myq, 1);
//	Print_Queue(&myq);
//	Get_Front(&myq, &a1);
//	Get_Rear(&myq, &a2);
//	printf("front is %d,rear is %d\n", a1, a2);
//	Clear(&myq);
//	Print_Queue(&myq);
//	Destroy(&myq);
//}
```

### 1.4.2链队列

#### 头文件（LQueue.h）

```c
//"LQueue.h"
#pragma once
#include<stdio.h>
#include<stdlib.h>
#include<assert.h>

typedef int ELEM_TYPE;
typedef struct Node {
	ELEM_TYPE data;
	struct Node* next;
}Node, * PNode;
typedef struct Head {
	struct Node* front;
	struct Node* rear;
	//int length;
}Head, * PHead;
//链队列
void Init_Lqueue(PHead phead);//初始化队列
bool En_LQueue(PHead phead, ELEM_TYPE val);//入队
bool De_LQueue(PHead phead, ELEM_TYPE* e);//出队
bool Get_Top(PHead phead, ELEM_TYPE* e);//获取队列顶部元素
int Get_Length(PHead phead);//获取其有效元素个数
bool IsEmpty(PHead phead);//判空
void Clear(PHead phead);//清空队列
void Destroy(PHead phead);//销毁队列
void Print(PHead phead);//打印队列
```

#### 源文件

```c
#include"LQueue.h"

void Init_Lqueue(PHead phead) {
	//初始化
	assert(phead != nullptr);
	if (phead == nullptr)return;
	phead->front = nullptr;
	phead->rear = nullptr;
}

bool En_LQueue(PHead phead, ELEM_TYPE val) {
	//入队
	assert(phead != nullptr);
	if (phead == nullptr)return false;
	Node* p = (Node*)malloc(sizeof(Node));
	if (p == nullptr) {
		printf("malloc failed\n");
		return false;
	}
	p->data = val;
	if (phead->front == nullptr) {
		//插入第一个元素
		p->next = nullptr;
		phead->front = p;
		phead->rear = p;
	}
	else {
		//不是第一个元素
		p->next = phead->rear->next;
		phead->rear->next = p;
		phead->rear = p;
	}
	return true;
}

bool De_LQueue(PHead phead, ELEM_TYPE* e) {
	//出队
	assert(phead != nullptr && e != nullptr);
	if (phead == nullptr || e == nullptr)return false;
	if (IsEmpty(phead)) {
		printf("queue is empty\n");
		return false;
	}
	if (phead->front->next == nullptr) {
		//只有一个元素
		Node* p = phead->front;
		*e = p->data;
		free(p);
		p = nullptr;
		phead->front = phead->rear = nullptr;
	}
	else {
		//不止一个元素
		Node* p = phead->front;
		*e = p->data;
		phead->front = p->next;
		free(p);
		p = nullptr;
	}
	return true;
}

bool Get_Top(PHead phead, ELEM_TYPE* e) {
	//获取队列顶部元素
	assert(phead != nullptr && e != nullptr);
	if (phead == nullptr || e == nullptr)return false;
	if (IsEmpty(phead)) {
		printf("queue is empty\n");
		return false;
	}
	*e = phead->front->data;
	return true;
}

int Get_Length(PHead phead) {
	//获取其有效元素个数
	assert(phead != nullptr);
	if (phead == nullptr)return false;
	int count = 0;
	Node* p = phead->front;
	for (p;p != nullptr;p = p->next) {
		count++;
	}
	return count;
}

bool IsEmpty(PHead phead) {
	//判空
	return phead->front == nullptr;
}

void Clear(PHead phead) {
	//清空
	assert(phead != nullptr);
	if (phead == nullptr)return;
	while (phead->front != nullptr) {
		Node* p = phead->front;
		phead->front = p->next;
		free(p);
		p = nullptr;
	}
	phead->front = nullptr;
	phead->rear = nullptr;
}

void Print(PHead phead) {
	//打印
	assert(phead != nullptr);
	if (phead == nullptr)return;
	Node* p = phead->front;
	for (p;p != nullptr;p = p->next) {
		printf("%d ", p->data);
	}
	printf("\n");
}

//int main() {
//	Head myhead;
//	Init_Lqueue(&myhead);
//	for (int i = 0;i < 20;i++) {
//		En_LQueue(&myhead, i + 1);
//	}
//	Print(&myhead);
//	int e = 0;
//	De_LQueue(&myhead, &e);
//	Print(&myhead);
//	printf("top->%d length = %d\n", e, Get_Length(&myhead));
//	Get_Top(&myhead, &e);
//	Print(&myhead);
//	printf("top->%d length = %d\n", e, Get_Length(&myhead));
//	Clear(&myhead);
//	return 0;
//}
```

## 1.5哈希表

哈希描述数据存储的一种方式。对每一个存入的数据，通过哈希函数计算得到对应的存储位置，所以原本数据中存在的顺序关系和哈希表中数据的顺序无关。理想状态是元素和存储位置之间构成单射，即每一个元素都有唯一确定存储位置，每一个存储位置对应唯一确定的元素，这样在查询操作时，用户输入查询元素，通过哈希函数的映射关系，可以立刻唯一确定其位置。在一般情况下，多个元素经过哈希函数计算后可能得到相同的值，由于一个存储位置只能存储一个元素，所以需要调整冲突元素的存储位置。对于顺序存储方式来说，通过向后偏移数据来实现；对于链式存储方式来说，冲突元素通过链表的方式连接在对应存储位置后面。下面给出链式哈希的操作代码参考。

#### 头文件（Hash.h）

```c
//"Hash.h"
#pragma once
#include<stdio.h>
#include<stdlib.h>
#include<assert.h>
#define HASHSIZE 12

typedef int ELEM_TYPE;
typedef struct Node {
	ELEM_TYPE data;
	struct Node* next;
}Node, * PNode;
typedef struct Hash {
	struct Node arr[HASHSIZE];
}Hash, * PHash;
//链式哈希
void Init_Hash(PHash phash);//初始化
bool Insert_Hash(PHash phash, ELEM_TYPE key);//插入
bool Del_Hash(PHash phash, ELEM_TYPE key);//删除
Node* Search(PHash phash, ELEM_TYPE key);//查找
void Print_Hash(PHash phash);//打印
```

#### 源文件

```c
#include"Hash.h"

void Init_Hash(PHash phash) {
	assert(phash != nullptr);
	if (phash == nullptr)return;
	for (int i = 0;i < HASHSIZE;i++) {
		phash->arr[i].next = nullptr;
	}
}

bool Insert_Hash(PHash phash, ELEM_TYPE key) {
	assert(phash != nullptr);
	if (phash == nullptr)return false;
	ELEM_TYPE hash = key % HASHSIZE;
	Node* p = (Node*)malloc(sizeof(Node));
	if (p == nullptr) {
		printf("malloc failed\n");
		return false;
	}
	p->data = key;
	//头插法
	p->next = phash->arr[hash].next;
	phash->arr[hash].next = p;
	return true;
}

bool Del_Hash(PHash phash, ELEM_TYPE key) {
	assert(phash != nullptr);
	if (phash == nullptr)return false;
	ELEM_TYPE hash = key % HASHSIZE;
	Node* p = &phash->arr[hash];
	for (p;p->next != nullptr;p = p->next) {
		if (p->next->data == key) {
			Node* q = p->next;
			p->next = q->next;
			free(q);
			q = nullptr;
			return true;
		}
	}
	return false;
}

Node* Search(PHash phash, ELEM_TYPE key) {
	ELEM_TYPE hash = key % HASHSIZE;
	Node* p = phash->arr[hash].next;
	for (p;p != nullptr;p = p->next) {
		if (p->data == key) {
			return p;
		}
	}
	return nullptr;
}

void Print_Hash(PHash phash) {
	for (int i = 0;i < HASHSIZE;i++) {
		printf("%3d: ", i);
		Node* p = phash->arr[i].next;
		for (p;p != nullptr;p = p->next) {
			printf("%d ", p->data);
		}
		printf("\n");
	}
}
//int main() {
//	Hash myhash;
//	Init_Hash(&myhash);
//	int ar[12] = { 13,32,65,82,29,56,19,4,78,47,55,37 };
//	for (int i = 0;i < 12;i++) {
//		Insert_Hash(&myhash, ar[i]);
//	}
//	Print_Hash(&myhash);
//	Node* p = Search(&myhash, 78);
//	printf("data: %d\n", p->data);
//	Del_Hash(&myhash, 19);
//	Print_Hash(&myhash);
//}
```

## 1.6栈和队列的应用

### 1.6.1两个栈实现队列

使用已经完成的顺序栈来实现队列的功能。顺序栈拥有扩容函数，所以构成的队列不需要考虑判满，受限于实现方式，构成的队列难以实现打印操作。

#### 头文件（Stack_To_Queue.h）

```c
//"Stack_To_Queue.h"
#pragma once
#include"Stack.h"

typedef struct Stack_To_Queue {
	Stack stack1;//每次入队时向stack1入栈
	Stack stack2;//每次出队时向stack2出栈，如果stack2为空，
				//则将stack1元素装入stack2中，再向stack2出栈
}stq, * pstq;
//两个栈实现一个队列
void my_Init_Queue(pstq pqueue);//初始化队列
bool my_En_Queue(pstq pqueue, ElemType val);//入队
bool my_De_Queue(pstq pqueue, ElemType* e);//出队，并获取出队元素的值
bool my_Get_Top(pstq pqueue, ElemType* e);//获取队头元素的值
bool my_IsEmpty(pstq pqueue);//判空
int my_Get_Length(pstq pqueue);///获取当前有效元素个数
void my_Clear(pstq pqueue);//清空队列
void my_Destroy(pstq pqueue);//销毁队列
```

#### 源文件

```c
#include"Stack_To_Queue.h"

void my_Init_Queue(pstq pqueue) {
	assert(pqueue != nullptr);
	if (pqueue == nullptr)return;
	Init_Stack(&pqueue->stack1);
	Init_Stack(&pqueue->stack2);
}
bool my_En_Queue(pstq pqueue, ElemType val) {
	assert(pqueue != nullptr);
	if (pqueue == nullptr) {
		printf("Push failed\n");
		return false;
	}
	Push(&pqueue->stack1, val);//入队操作均对栈1进行入栈
	return true;
}
bool my_De_Queue(pstq pqueue, ElemType* e) {
	assert(pqueue != nullptr && e != nullptr);
	if (pqueue == nullptr || e == nullptr) {
		printf("Pop failed\n");
		return false;
	}
	if (my_IsEmpty(pqueue)) {
		printf("This is an empty stack\n");
		return false;
	}
	if (IsEmpty(&pqueue->stack2)) {//如果栈2为空
		while (!IsEmpty(&pqueue->stack1)) {//将栈1中的所有元素转移到栈2
			ElemType tmp;
			Pop(&pqueue->stack1, &tmp);
			Push(&pqueue->stack2, tmp);
		}
	}
	return Pop(&pqueue->stack2, e);//从栈2中出栈，实现出队的操作
}
bool my_Get_Top(pstq pqueue, ElemType* e) {
	assert(pqueue != nullptr && e != nullptr);
	if (pqueue == nullptr || e == nullptr) {
		printf("Get_Top failed\n");
		return false;
	}
	if (my_IsEmpty(pqueue)) {
		printf("This is an empty stack\n");
		return false;
	}
	if (IsEmpty(&pqueue->stack2)) {
		while (!IsEmpty(&pqueue->stack1)) {
			ElemType tmp;
			Pop(&pqueue->stack1, &tmp);
			Push(&pqueue->stack2, tmp);
		}
	}
	return Get_Top(&pqueue->stack2, e);
    
}
bool my_IsEmpty(pstq pqueue) {
	bool flag = false;
	if (IsEmpty(&pqueue->stack1) && IsEmpty(&pqueue->stack2)) {
		flag = true;
	}
	return flag;
}
int my_Get_Length(pstq pqueue) {
	return Get_Length(&pqueue->stack1) + Get_Length(&pqueue->stack2);

}
void my_Clear(pstq pqueue) {
	Clear(&pqueue->stack1);
	Clear(&pqueue->stack2);
}
void my_Destroy(pstq pqueue) {
	Destroy(&pqueue->stack1);
	Destroy(&pqueue->stack2);
}

//int main() {
//	ElemType value1;
//	ElemType value2;
//	stq mystq;
//
//	my_Init_Queue(&mystq);
//	my_De_Queue(&mystq, &value1);
//	for (int i = 0; i < 10; i++) {
//		my_En_Queue(&mystq, i + 1);
//	}
//
//	my_Get_Top(&mystq, &value1);
//	printf("Top value is %d,", value1);
//	printf("current length is %d\n", my_Get_Length(&mystq));
//
//	for (int i = 0;i < 3;i++) {
//		my_De_Queue(&mystq, &value2);
//		printf("Pop value is %d,", value2);
//		printf("current length is %d\n", my_Get_Length(&mystq));
//	}
//
//	my_Get_Top(&mystq, &value1);
//	printf("Top value is %d,", value1);
//	printf("current length is %d\n", my_Get_Length(&mystq));
//	return 0;
//}
```

### 1.6.2两个队列实现栈

通过已经完成的循环队列来实现栈的功能。由于循环队列设置为固定长度，所以构成的栈的最大长度为一个队列的最大长度，需要注意的是，在不执行操作的时候，两个队列应该只有一个队列存在元素。

#### 头文件（Queue_To_Stack.h）

```c
//"Queue_To_Stack.h"
#pragma once
#include"Queue.h"

typedef struct Queue_To_Stack {
	Queue queue1;
	Queue queue2;
}qts, * pqts;
//两个队列实现一个栈
void my_Init_Stack(pqts pstack);//初始化栈
bool my_Push(pqts pstack, ELEM_TYPE val);//入栈
bool my_Pop(pqts pstack, ELEM_TYPE* e);//出栈，并获取出栈元素的值
bool my_Get_Top(pqts pstack, ELEM_TYPE* e);//获取栈顶元素的值
int my_Get_Length(pqts pstack);//获取当前有效元素的个数
bool my_IsEmpty(pqts pstack);//判空
bool my_IsFull(pqts pstack);//判满
void my_Clear(pqts pstack);//清空栈
void my_Destroy(pqts pstack);//销毁栈
void my_Print_Stack(pqts pstack);//打印栈
```

#### 源文件

```c
#include"Queue_To_Stack.h"

void my_Init_Stack(pqts pstack) {
	//初始化栈
	assert(pstack != nullptr);
	if (pstack == nullptr)return;
	Init_Queue(&pstack->queue1);
	Init_Queue(&pstack->queue2);
}
bool my_Push(pqts pstack, ELEM_TYPE val) {
	//入栈
	assert(pstack != nullptr);
	if (pstack == nullptr)return false;
	if (my_IsFull(pstack)) {
		printf("Stack is full\n");
		return false;
	}
	if (!IsEmpty(&pstack->queue1)) {//如果队列1不空
		return En_Queue(&pstack->queue1, val);//向队列1入队
	}
	else {
		return En_Queue(&pstack->queue2, val);//否则向队列2入队
	}
}
bool my_Pop(pqts pstack, ELEM_TYPE* e) {
	//出栈，并获取出栈元素的值
	assert(pstack != nullptr && e != nullptr);
	if (pstack == nullptr || e == nullptr) {
		printf("Pop failed\n");
		return false;
	}
	if (my_IsEmpty(pstack)) {
		printf("This is an empty stack\n");
		return false;
	}	
	ELEM_TYPE tmp;
	if (!IsEmpty(&pstack->queue1)) {//如果队列1不空
		int size = Get_Length(&pstack->queue1);
		while (size > 1) {//队列1出队，并向队列2入队，直到队列1剩余最后一个元素
			De_Queue(&pstack->queue1, &tmp);
			En_Queue(&pstack->queue2, tmp);
			size -= 1;
		}
		return De_Queue(&pstack->queue1, e);//将队列1最后一个元素出队，实现出栈的操作
	}
	else {//队列2不空同理
		int size = Get_Length(&pstack->queue2);
		while (size > 1) {
			De_Queue(&pstack->queue2, &tmp);
			En_Queue(&pstack->queue1, tmp);
			size -= 1;
		}
		return De_Queue(&pstack->queue2, e);
	}
}
bool my_Get_Top(pqts pstack, ELEM_TYPE* e) {
	//获取栈顶元素的值
	assert(pstack != nullptr && e != nullptr);
	if (pstack == nullptr || e == nullptr) {
		printf("Get_top failed\n");
		return false;
	}
	if (my_IsEmpty(pstack)) {
		printf("This is an empty stack\n");
		return false;
	}
	if (!IsEmpty(&pstack->queue1)) {//队列1不空
		return Get_Rear(&pstack->queue1, e);//获取队尾元素，这个元素就是需要的栈顶元素
	}
	else {
		return Get_Rear(&pstack->queue2, e);
	}
}
int my_Get_Length(pqts pstack) {
	//获取当前有效元素的个数
	return Get_Length(&pstack->queue1) + Get_Length(&pstack->queue2);
}
bool my_IsEmpty(pqts pstack) {
	//判空
	return IsEmpty(&pstack->queue1) && IsEmpty(&pstack->queue2);
}
bool my_IsFull(pqts pstack) {
	//判满
	if (!IsEmpty(&pstack->queue1)) {
		return IsFull(&pstack->queue1);
	}
	return IsFull(&pstack->queue2);
}
void my_Clear(pqts pstack) {
	//清空栈
	Clear(&pstack->queue1);
	Clear(&pstack->queue2);
}
void my_Destroy(pqts pstack) {
	//销毁栈
	Destroy(&pstack->queue1);
	Destroy(&pstack->queue2);
}
void my_Print_Stack(pqts pstack) {
	//打印栈
	assert(pstack != nullptr);
	if (pstack == nullptr) {
		printf("print failed\n");
		return;
	}
	if (!IsEmpty(&pstack->queue1)) {
		Print_Queue(&pstack->queue1);
	}
	else {
		Print_Queue(&pstack->queue2);
	}
}

//int main() {
//	qts mystack;
//	my_Init_Stack(&mystack);
//	for (int i = 0;i < 4;i++) {
//		my_Push(&mystack, i + 10);
//	}
//	my_Print_Stack(&mystack);
//	ELEM_TYPE e = -1;
//	my_Pop(&mystack, &e);
//	printf("\npop->%d\n", e);
//	my_Print_Stack(&mystack);
//	my_Get_Top(&mystack, &e);
//	printf("\ntop->%d\n", e);
//	my_Print_Stack(&mystack);
//	my_Clear(&mystack);
//	my_Print_Stack(&mystack);
//	my_Destroy(&mystack);
//	return 0;
//}
```

# 2.串

串主要针对字符串而言，常见的有字符串操作有拷贝、拼接、比较、长度等，这里主要介绍另一种字符串的使用：字符串匹配。意思是存在一个主串，对于用户给出的任何子串，函数都可以得到该子串在主串当中的位置（如果不存在该子串，则返回失败）。

## 2.1朴素算法

朴素算法，也叫BF算法，实现原理简单易懂，缺点是时间复杂度高，如果主串长度为N，子串的长度为M，那么时间复杂度为O(N*M)。

```c
int BF_Search(const char* str, const char* sub, int pos) {
	assert(str != nullptr && sub != nullptr && pos >= 0 && pos < strlen(str));
	if (str == nullptr || sub == nullptr || pos < 0 || pos >= strlen(str)) {
		printf("Search failed\n");
		return -1;
	}

	int lenstr = strlen(str);//主串的长度
	int lensub = strlen(sub);//子串的长度
	int i = pos;//主串匹配时的下标
	int j = 0;//子串匹配时的下标
	while (i < lenstr && j < lensub) {
		if (str[i] == sub[j]) {
			i++;
			j++;
		}
		else {//匹配不成功时
			i = i - j + 1;//主串指针回退到本次匹配开始位置的下一个位置
			j = 0;//子串指针回退到开头
		}
	}

	if (j >= lensub) {//如果子串与主串成功匹配
		return i - j;//返回子串在主串中的位置
	}
	else {
		printf("Can't find str : \"%s\"\n", sub);
		return -1;
	}
}
```

## 2.2KMP算法

在KMP算法中，主串指针一定不回退，并且子串的回退位置根据next数组确定，其中next数组是由也子串唯一确定的。

```c
int* Get_Next(const char* sub) {
	int lensub = strlen(sub);
	int* next = (int*)malloc(sizeof(int) * lensub);
	assert(next != nullptr);

	//默认值设定
	next[0] = -1;
	next[1] = 0;

	int j = 1;
	int k = 0;

	while (j + 1 < lensub) {//获取next数组
		if ((k == -1) || sub[j] == sub[k]) {
			k++;
			j++;
			next[j] = k;
		}
		else {
			k = next[k];
		}
	}
	return next;
}

int KMP_Search(const char* str, const char* sub, int pos) {
	assert(str != nullptr && sub != nullptr && pos >= 0 && pos < strlen(str));
	if (str == nullptr || sub == nullptr || pos < 0 || pos >= strlen(str)) {
		printf("Search failed\n");
		return -1;
	}

	int lenstr = strlen(str);//主串的长度
	int lensub = strlen(sub);//子串的长度
	int i = pos;//主串匹配时的下标
	int j = 0;//子串匹配时的下标

	int* next = Get_Next(sub);//得到当前子串的next数组

	while (i < lenstr && j < lensub) {
		if ((j == -1) || str[i] == sub[j]) {
			i++;
			j++;
		}
		else {//匹配不成功时
			j = next[j];//子串指针根据next数组回退到相应的位置
		}
	}

	if (j >= lensub) {
		return i - j;
	}
	else {
		printf("can't find str : \"%s\"\n", sub);
		return -1;
	}

}
```

# 3.排序算法

八大排序算法：选择排序，插入排序，希尔排序，冒泡排序，归并排序，基数排序，堆排序，快速排序。
稳定的算法：插入排序，冒泡排序，归并排序，基数排序。
不稳定的算法：选择排序，希尔排序，快速排序，堆排序。

## 3.1插入排序

插入排序的思路是认为存在一个有序序列（开始时只有首元素），每一次循环将不在这个序列里的一个元素通过比较相邻元素然后交换的方式插入到该序列的合适位置，从而使得这个有序序列不断增加，直到所有元素都在这个序列当中时，排序完成。

```c
void Insert_Sort(int* arr, int len) {
	assert(arr != NULL);
	if (arr == NULL) {
		printf("insert failed\n");
		return;
	}
	int tmp, j;
	for (int i = 1; i < len; i++) {
		tmp = arr[i];
		for (j = i - 1; j >= 0; j--) {
			if (arr[j] > tmp) {
				arr[j + 1] = arr[j];
			}
			else {
				break;
			}
		}
		arr[j + 1] = tmp;
	}
}
```

## 3.2希尔排序

希尔排序可以说是插入排序的升级版本，加入了希尔函数，即所谓的“步长”，本质上采用的还是插入排序的思路。

```c
static void shell(int* arr, int len, int gap) {
	int tmp, j;
	for (int i = gap; i < len; i++)	{
		tmp = arr[i];
		for (j = i - gap; j >= 0; j = j - gap) {
			if (arr[j] > tmp) {
				arr[j + gap] = arr[j];
			}
			else {
				break;
			}
		}
		arr[j + gap] = tmp;
	}
}
void Shell_Sort(int* arr, int len) {
	assert(arr != nullptr);
	if (arr == nullptr) {
		printf("shell failed\n");
		return;
	}
	int gap[] = { 5, 3, 1 };
	int lengap = sizeof(gap) / sizeof(gap[0]);
	for (int i = 0; i < lengap; i++) {
		shell(arr, len, gap[i]);
	}
}
```

## 3.3冒泡排序

```c
void Bubble_Sort(int* arr, int len) {
    assert(arr != nullptr);
	if (arr == nullptr) {
		printf("bubble failed\n");
		return;
	}
	bool tag = true;
	for (int i = 0; i < len - 1; i++) {
		tag = true;
		for (int j = 0; j < len - i - 1; j++) {
			if (arr[j] > arr[j + 1]) {
				tag = false;
				int tmp = arr[j];
				arr[j] = arr[j + 1];
				arr[j + 1] = tmp;
			}
		}
		if (tag) {
			break;
		}
	}
}
```

## 3.4选择排序

选择排序的思路是认为存在一个有序序列（开始时没有元素在其中），每一次循环都会从非有序序列中寻找一个键值最小的加入到有序序列中，直到排定所有元素为止。

```c
void Select_Sort(int* arr, int len) {
	assert(arr != nullptr);
	if (arr == nullptr) {
		printf("select failed\n");
		return;
	}
	int minindex;
	for (int i = 0;i < len - 1;i++) {
		minindex = i;
		for (int j = i + 1;j < len;j++) {
			if (arr[j] < arr[minindex]) {
				minindex = j;
			}
		}
		if (i != minindex) {
			int tmp = arr[i];
			arr[i] = arr[minindex];
			arr[minindex] = tmp;
		}
	}
}
```

## 3.5归并排序

归并排序分步对待序列排序，每次将数据分成小组（开始时是两两比较），小组内有序后，按照2的幂扩大小组的规模，直到小组足以覆盖所有元素的时候，所有元素就被排定。

```c
static void merge(int* arr, int len, int step) {
	int low1, low2, high1, high2, i;
	int* brr = (int*)malloc(sizeof(int) * len);
	assert(brr != nullptr);

	i = 0;
	low1 = 0;
	high1 = low1 + step - 1;
	low2 = high1 + 1;
	high2 = low2 + step - 1 < len ? low2 + step - 1 : len - 1;

	while (low2 < len) {
		while (low1 <= high1 && low2 <= high2) {
			if (arr[low1] <= arr[low2]) {
				brr[i++] = arr[low1++];
			}
			else {
				brr[i++] = arr[low2++];
			}
		}
		while (low1 <= high1) {
			brr[i++] = arr[low1++];
		}
		while (low2 <= high2) {
			brr[i++] = arr[low2++];
		}
		low1 = high2 + 1;
		high1 = low1 + step - 1;
		low2 = high1 + 1;
		high2 = low2 + step - 1 < len ? low2 + step - 1 : len - 1;
	}

	while (low1 < len) {
		brr[i++] = arr[low1++];
	}
	for (int i = 0;i < len;i++) {
		arr[i] = brr[i];
	}
	free(brr);
	brr = nullptr;
}
void Merge_Sort(int* arr, int len) {
	assert(arr != nullptr);
	if (arr == nullptr) {
		printf("merge failed\n");
		return;
	}
	
	for (int i = 1;i < len;i *= 2) {
		merge(arr, len, i);
	}
}
```

## 3.6堆排序

堆排序使用完全二叉树的思想组织一个数组，在算法上实现堆有序，然后将堆中最大元素和最后一个结点交换，认为有序元素加一，交换仅针对无序元素，所以当全部无序元素交换完毕，全部元素有序。

```c
void heap(int* arr, int start, int end) {
	int tmp = arr[start];

	for (int i = start * 2 + 1; i <= end; i = start * 2 + 1) {//语句3  精髓  时间复杂度O（nlogn）的原因
		if (i < end && arr[i] < arr[i + 1]) {//有右孩子 并且右孩子比左孩子大 
			i++;
		}
		//如果if为假  代表要么右孩子不存在  要么右孩子存在  但是小于左孩子
		//此时i保存的是左右孩子中较大的值的下标
		//接着让父子比较

		if (arr[i] > tmp) {
			arr[start] = arr[i];
			start = i;
		}
		else {
			break;
		}
	}
	//此时for循环退出了，要么此时触底  要么if(arr[i]>tmp)为假  break跳出循环

	arr[start] = tmp;
}
void Heap_Sort(int* arr, int len) {
	//先调整成大顶堆
	for (int i = (len - 1 - 1) / 2; i >= 0; i--) {//O(n)
		heap(arr, i, len - 1);//(logn)
	}//两个一乘  则时间复杂度O(nlogn)

	//根节点和尾节点交换
	for (int i = 0; i < len - 1; i++) {//O(n)
		int tmp = arr[0];
		arr[0] = arr[len - 1 - i];
		arr[len - 1 - i] = tmp;

		heap(arr, 0, (len - 1 - i) - 1);//(len-1-i)相当于最后一个节点的下标  然后最后一个节点不参与计算 则再-1
	}
}
```

## 3.7基数排序

基数排序利用数据每一位上的数字来排序，从个位开始，每一次都会排定一些元素，直到最高位结束，所有元素都有序。

```c
static int get_figure(int* arr, int len) {
	//获取最大位数
	int tmp = 0;
	for (int i = 0;i < len;i++) {
		if (arr[i] > tmp) {
			tmp = arr[i];
		}
	}
	int count = 0;
	while (tmp != 0) {
		count++;
		tmp /= 10;
	}
	return count;
}
static int get_num(int n, int fin) {
	//获取fin位的数字
	for (int i = 0;i < fin;i++) {
		n /= 10;
	}
	return n % 10;
}
static void radix(int* arr, int len, int fin) {
	int bucket[10][20] = { 0 };
	int num[10] = { 0 };
	for (int i = 0;i < len;i++) {
		int index = get_num(arr[i], fin);
		bucket[index][num[index]] = arr[i];
		num[index]++;
	}
	int k = 0;
	for (int i = 0;i < 10;i++) {
		for (int j = 0;j < num[i];j++) {
			arr[k++] = bucket[i][j];
		}
	}
}
static void radix_queue(int* arr, int len, int fin) {
    //使用队列实现的基数排序
	Head arr_queue[10];
	for (int i = 0;i < 10;i++) {
		Init_Lqueue(&arr_queue[i]);//初始化十个队列
	}
	for (int i = 0;i < len;i++) {
		int index = get_num(arr[i], fin);//获取fin位的数字
		En_Lqueue(&arr_queue[index], arr[i]);//根据fin位的数字把数据送入相应的队列
	}
	int k = 0;
	for (int i = 0;i < 10;i++) {
		while (!IsEmpty(&arr_queue[i])) {
			De_Lqueue(&arr_queue[i], &arr[k++]);//把所有队列中的数据出队
		}
	}
}
void Radix_Sort(int* arr, int len) {
	assert(arr != nullptr);
	if (arr == nullptr) {
		printf("radix failed\n");
		return;
	}
	int count = get_figure(arr, len);
	for (int i = 0;i < count;i++) {
		//radix(arr, len, i);
		radix_queue(arr, len, i);
	}
}
```

## 3.8快速排序

快速排序首先选取一个元素，移动这个元素，使其左边的数据都不大于它，右边的数据都不小于它，也就是说这个元素在将来有序序列中的位置已经确定，这个操作叫做“划分”，可以看做这个元素将所有数据“一分为二”，一般递归这个划分过程来排定所有元素。

```c
static int partition(int* arr, int left, int right) {
	int tmp = arr[left];
	while (left < right) {
		while (left < right && arr[right] >= tmp)right--;
		arr[left] = arr[right];
		while (left < right && arr[left] <= tmp)left++;
		arr[right] = arr[left];
	}
	arr[left] = tmp;
	return left;
}
static void quick(int* arr, int left, int right) {
	if (left < right) {
		int par = partition(arr, left, right);
		quick(arr, left, par - 1);
		quick(arr, par + 1, right);
	}
}
static void quick_stack(int* arr, int left, int right) {
    //通过栈来实现快速排序
	LStack st;
	Init_Stack(&st);//初始化一个栈

	if (left < right) {//首先进行一次划分
		int par = partition(arr, left, right);
		if (left < par - 1) {//将划分后左边数据边界入栈
			Push(&st, left);
			Push(&st, par - 1);
		}
		if (par + 1 < right) {//将划分后右边数据边界入栈
			Push(&st, par + 1);
			Push(&st, right);
		}
	}

	while (!IsEmpty(&st)) {//循环进行划分
		int p, q;
		Pop(&st, &q);//将栈中的边界值弹出
		Pop(&st, &p);
		int par = partition(arr, p, q);//通过存储在栈中的边界值调用划分方法
		if (p < par - 1) {//同样，将新的边界值入栈
			Push(&st, p);
			Push(&st, par - 1);
		}
		if (par + 1 < q) {
			Push(&st, par + 1);
			Push(&st, q);
		}
	}
}
void Quick_Sort(int* arr, int len) {
	assert(arr != nullptr);
	if (arr == nullptr) {
		printf("quick failed\n");
		return;
	}
	//quick(arr, 0, len - 1);
	quick_stack(arr, 0, len - 1);
}
```

